<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小的毛毛虫</title>
  <icon>https://www.gravatar.com/avatar/d1ef88200293f35641bebedc91aa7821</icon>
  <subtitle>小小的毛毛虫，也想要破茧成蝶</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/"/>
  <updated>2020-08-07T10:14:01.000Z</updated>
  <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/</id>
  
  <author>
    <name>gaoxiang</name>
    <email>630268696@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Java虚拟机其二</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/08/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B6%E4%BA%8C/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/08/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B6%E4%BA%8C/</id>
    <published>2020-08-07T10:14:01.000Z</published>
    <updated>2020-08-07T10:14:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>文章内容参考《深入理解Java虚拟机》 周志明 著</p><div class="note info flat"><p>直到看了这本书我才发现，我之前对 JVM 堆栈 的理解全是错的 😭，还好面试的时候都是直接说 不会/不了解 😂</p></div><div class="note success flat"><p>Java 虚拟机有很多类型，不同类型的虚拟机拥有不同的特性。书内介绍的为 业界的通常做法</p></div><h3 id="运行时数据区域"><a class="markdownIt-Anchor" href="#运行时数据区域"></a> 运行时数据区域</h3><p>一般情况下，Java虚拟机所管理的内存包括如下几个运行时数据区域：</p><p><img src= "/img/loading.gif" data-lazy-src="C:%5CUsers%5C63026%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200807184654415.png" alt="image-20200807184654415" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面的话&quot;&gt;&lt;/a&gt; 写在前面的话&lt;/h1&gt;
&lt;p&gt;文章内容参考《深入理解Java虚拟机》 周志明 著&lt;/p&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>书籍目录</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/08/05/%E4%B9%A6%E7%B1%8D%E7%9B%AE%E5%BD%95/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/08/05/%E4%B9%A6%E7%B1%8D%E7%9B%AE%E5%BD%95/</id>
    <published>2020-08-05T12:51:38.000Z</published>
    <updated>2020-08-05T12:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>买书嘛，总怕物无所值。咱在此列出已购买的 kindle 图书，假如有童鞋想要借阅的话，可以联系我 哦</p><p>hexo 应该是有插件支持的，等俺闲下来一定搞一个 😂</p><h3 id="计算机相关书籍"><a class="markdownIt-Anchor" href="#计算机相关书籍"></a> 计算机相关书籍：</h3><h4 id="深入理解-java-虚拟机-周志明著"><a class="markdownIt-Anchor" href="#深入理解-java-虚拟机-周志明著"></a> 《深入理解 Java 虚拟机》 周志明著</h4><h4 id="h265hevc-视频编码朱秀昌刘峰-著"><a class="markdownIt-Anchor" href="#h265hevc-视频编码朱秀昌刘峰-著"></a> 《H.265/HEVC 视频编码》朱秀昌，刘峰 著</h4><h4 id="spring-5-核心原理-与-30个类手写实战-谭勇德-著"><a class="markdownIt-Anchor" href="#spring-5-核心原理-与-30个类手写实战-谭勇德-著"></a> 《Spring 5 核心原理 与 30个类手写实战》 谭勇德 著</h4><h4 id="postgresql-11-从入门到精通-李小威-著"><a class="markdownIt-Anchor" href="#postgresql-11-从入门到精通-李小威-著"></a> 《PostgreSQL 11 从入门到精通》 李小威 著</h4><h3 id="科学杂刊"><a class="markdownIt-Anchor" href="#科学杂刊"></a> 科学杂刊</h3><h4 id="生命是什么-艾尔温薛定谔-著"><a class="markdownIt-Anchor" href="#生命是什么-艾尔温薛定谔-著"></a> 《生命是什么》 艾尔温·薛定谔 著</h4><h3 id="历史书籍"><a class="markdownIt-Anchor" href="#历史书籍"></a> 历史书籍</h3><h4 id="毛爷爷传-罗斯特里尔-著"><a class="markdownIt-Anchor" href="#毛爷爷传-罗斯特里尔-著"></a> 《毛爷爷传》 罗斯·特里尔 著</h4><h4 id="日本史-坂本太郎-著"><a class="markdownIt-Anchor" href="#日本史-坂本太郎-著"></a> 《日本史》 坂本太郎 著</h4><h3 id="侦探悬疑"><a class="markdownIt-Anchor" href="#侦探悬疑"></a> 侦探悬疑</h3><h4 id="罗杰疑案-阿加莎克里斯蒂-著"><a class="markdownIt-Anchor" href="#罗杰疑案-阿加莎克里斯蒂-著"></a> 《罗杰疑案》 阿加莎·克里斯蒂 著</h4><h4 id="首无作祟之物三津田信三-著-font-color-red强烈推荐font"><a class="markdownIt-Anchor" href="#首无作祟之物三津田信三-著-font-color-red强烈推荐font"></a> 《首无·作祟之物》三津田信三 著 <font color = red>强烈推荐</font></h4><h4 id="山魔嗤笑之物三津田信三-著"><a class="markdownIt-Anchor" href="#山魔嗤笑之物三津田信三-著"></a> 《山魔·嗤笑之物》三津田信三 著</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面的话&quot;&gt;&lt;/a&gt; 写在前面的话&lt;/h1&gt;
&lt;p&gt;买书嘛，总怕物无所值。咱在此列出已购买的 kindle 图书，假如有童鞋想要借阅的话，可以联系我 哦&lt;/p&gt;
&lt;p&gt;he
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【每日一题Day 5】 沦为扒手的程序员</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/08/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%205/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/08/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%205/</id>
    <published>2020-08-05T03:57:57.000Z</published>
    <updated>2020-08-05T03:57:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精神领袖附身的-程序员"><a class="markdownIt-Anchor" href="#精神领袖附身的-程序员"></a> 精神领袖附身的 程序员</h1><p>怎么偷，偷那些，这是个问题🙈🙉🙊🐵</p><h3 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍"></a> <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h3><p>Difficulty: <strong>简单</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><div class="note info">            <p>本题比较直观，几乎可以一眼看出来使用迭代法或者动态规划，不再进行分析，直接上代码</p>          </div><h5 id="动态转移方程"><a class="markdownIt-Anchor" href="#动态转移方程"></a> 动态转移方程：</h5><p>​<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[n] = max(f[n-1], f[n-2] + num[n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n \in(0,nums.length)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></p><p>多 BB 一句：</p><ul><li>请详细的限制不符合公式的条件： nums == null || nums.length == 1|| nums.length == 0  避免重复运行拉低通过率 😂</li></ul><h5 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(0) = 0; f(1) = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节省内存资源，用两个数字存储结果</span></span><br><span class="line">        <span class="comment">// 前者表示 f[n-2], 后者表示 f[n-1]</span></span><br><span class="line">        <span class="keyword">int</span> numOne = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numTwo = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> resultNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 很明显越往后数字越大，遍历结束就能得到结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            resultNum = Math.max(numOne + nums[i], numTwo);</span><br><span class="line">            numOne = numTwo;</span><br><span class="line">            numTwo = resultNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultNum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="213-打家劫舍ii"><a class="markdownIt-Anchor" href="#213-打家劫舍ii"></a> <a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍II</a></h3><p>Difficulty: <strong>中等</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下，**能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><h4 id="方法一动态规划"><a class="markdownIt-Anchor" href="#方法一动态规划"></a> 方法一：动态规划</h4><div class="note info">            <p>小小的思考：</p><p>与打家劫舍I区别在于多了 首尾的限制。我认为可以分别以第一位、第二位为起始点重复动态规划，挑选最大的结果</p>          </div><ul><li>注意以第一位为起始点时，不包含末尾的房屋</li></ul><h5 id="实现代码-2"><a class="markdownIt-Anchor" href="#实现代码-2"></a> 实现代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 节省内存资源，用两个数字存储结果</span></span><br><span class="line">       <span class="comment">// 前者表示 f[n-2], 后者表示 f[n-1],强制选择第一个数字</span></span><br><span class="line">       <span class="keyword">int</span> numOne = <span class="number">0</span> - nums[<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span> numTwo = nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> resultOne = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 很明显越往后数字越大，遍历结束就能得到结果</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           resultOne = Math.max(numOne + nums[i], numTwo);</span><br><span class="line">           numOne = numTwo;</span><br><span class="line">           numTwo = resultOne;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 强制选择第二个数字</span></span><br><span class="line">       numOne = <span class="number">0</span>;</span><br><span class="line">       numTwo = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> resultTwo = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           resultTwo = Math.max(numOne + nums[i], numTwo);</span><br><span class="line">           numOne = numTwo;</span><br><span class="line">           numTwo = resultTwo;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resultOne &gt; resultTwo ? resultOne : resultTwo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>虽说解决了问题，但本质上并不是严谨的动态规划 （好吧我觉得毕竟加了判断，动态规划偏 数列 的感觉）</li><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="方法二贪心算法"><a class="markdownIt-Anchor" href="#方法二贪心算法"></a> 方法二：贪心算法</h4><div class="note info">            <p>没看太懂，还是等等再说把</p>          </div><p><a href="https://leetcode-cn.com/problems/house-robber-ii/solution/python3-tan-xin-suan-fa-by-ting-ting-28/" target="_blank" rel="noopener">打家劫舍贪心解法</a></p><h3 id="337-打家劫舍-iii"><a class="markdownIt-Anchor" href="#337-打家劫舍-iii"></a> <a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h3><p>Difficulty: <strong>中等</strong></p><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h4><ul><li>对于本题，经过分析不难发现，父树与子树之间满足 打家劫舍I 中的关系。</li><li>当前节点所能得到的金钱 等于<Strong>所有子树所能得到金钱的和</Strong>  与 <Strong>所有孙树所能得到的金钱的和与当前节点的和</Strong> 中的较大者</li></ul><div class="note warning">            <p>上述第二条结论并不正确，树的特殊性决定，孙树跟子树的结合 可能大于 孙树与孙树 的结合，因此应该是：</p><p>Max(右子树、右子树的孙树) + Max(左子树、左子树的孙树)</p><p>原因： 对于本题 我们仅仅是记录了右子树的最大值、右子树孙树的最大值，并没有比较这两个值的大小</p>          </div><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dfs(TreeNode node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较选择当前节点与不选择当前节点所偷窃的金额差值</span></span><br><span class="line">        <span class="comment">// 偷取当前节点，则只能获得孙节点值，反之可以选择孙节点与子节点最大组合</span></span><br><span class="line">        <span class="keyword">int</span>[] leftResult = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] rightResult = dfs(node.right);</span><br><span class="line">        <span class="keyword">int</span> selectNode = leftResult[<span class="number">1</span>] + rightResult[<span class="number">1</span>] + node.val;</span><br><span class="line">        <span class="keyword">int</span> unSelectNode = Math.max(leftResult[<span class="number">0</span>], leftResult[<span class="number">1</span>]) + Math.max(rightResult[<span class="number">0</span>], rightResult[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selectNode,unSelectNode&#125;; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很尴尬 我自己并没有码出来，呵呵 ，该问题的难点在于怎么传递两个子数据</p><p><font color =purple><strong>🧠说 我悟了 手告诉你 你还差的远呢 😂</strong></font></p><ul><li>本题的难点在实现这一块，很明显对于本题要使用 <font color = purple><strong>后序遍历</strong></font> 的形式</li><li>本题处理 f[n-2] 与 f[n-1] 的具体实现方式非常巧，要学习掌握下才好</li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>打家劫舍问题很容易看出要用动态规划解决，与此相关的还有 <a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a>。 当然，这道题比较难，咱们来日再谈 😀</p><p>这一系列题目昭示了一个真理，学好编程学好算法，当小偷都比别人强  😂😂</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精神领袖附身的-程序员&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#精神领袖附身的-程序员&quot;&gt;&lt;/a&gt; 精神领袖附身的 程序员&lt;/h1&gt;
&lt;p&gt;怎么偷，偷那些，这是个问题🙈🙉🙊🐵&lt;/p&gt;
&lt;h3 id=&quot;198-打家劫舍&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-02T13:59:36.000Z</published>
    <updated>2020-08-02T13:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>目前无论哪种语言都已经提供了排序的接口，我们甚至可以自己定义比对函数实现排序功能。但是奈何排序是面试的高发题，不整理下我寝食难安啊 😂</p><h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2><ul><li>重复遍历要排序的元素列，依次比较相邻的元素，直到没有相邻的元素需要交换</li><li>实现过程：每轮比较保证将当前比较范围的最值移动到正确的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BubbleSort(<span class="keyword">int</span>[] numArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = numArray.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length - <span class="number">1</span> - i; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numArray[k] &gt; numArray[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tempNum = numArray[k + <span class="number">1</span>];</span><br><span class="line">                    numArray[k + <span class="number">1</span>] = numArray[k];</span><br><span class="line">                    numArray[k] = tempNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2><ul><li>遍历待排序的数组，每次从数据元素中选出最小值，放在序列的起始位置，直到待排序数据为空</li><li>实现过程：本质上与冒泡排序相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] SelectionSort(<span class="keyword">int</span>[] numArray) &#123;</span><br><span class="line">       <span class="keyword">int</span> length = numArray.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> tempNum = i;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (numArray[tempNum] &gt; numArray[j]) &#123;</span><br><span class="line">                   tempNum = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> temp = numArray[i];</span><br><span class="line">           numArray[i] = numArray[tempNum];</span><br><span class="line">           numArray[tempNum] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> numArray;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2><ul><li>类似玩扑克牌时整理手牌，哈哈也可以视为有目的的冒泡排序</li><li>实现过程：每次为一张牌找到正确的位置，直到所有牌到达正确的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] InsertSort(<span class="keyword">int</span>[] numArray) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = numArray.length;</span><br><span class="line">    <span class="comment">// 相比于每个数字后移一位，插入的数字与比较的数字交换更直观</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; numArray[j] &lt; numArray[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempNum = numArray[j];</span><br><span class="line">            numArray[j] = numArray[j - <span class="number">1</span>];</span><br><span class="line">            numArray[j - <span class="number">1</span>] = tempNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><ul><li>很有名的排序了，选择当前数组内的一个数字，以其为基准，将大于或小于他的数字分别移动到数组的两端，递归判断最终即可对原数组排序</li><li>感觉上跟二分法相当类似</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numArray 存储数组的引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left     比较范围左下标 (包含该下标）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right    比较范围右下标 (包含该下标)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] numArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择最右边的值作为参照，比该值小的放在左边，比该值大的放在右边</span></span><br><span class="line">    <span class="comment">// 意识到一个问题， int 数组应该是引用传递吧 😂</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m 标记了当前比目标值小的数字的个数</span></span><br><span class="line">    <span class="keyword">int</span> m = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numArray[i] &lt; numArray[right]) &#123;</span><br><span class="line">            <span class="comment">// 与传统的从两头开始比较替换不同，这里从单方向比较，虽说增加了多余的交换动作，但是代码更直观了</span></span><br><span class="line">            <span class="keyword">int</span> tempNum = numArray[i];</span><br><span class="line">            numArray[i] = numArray[m];</span><br><span class="line">            numArray[m] = tempNum;</span><br><span class="line">            m++; <span class="comment">// 标记下一个替换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将比较值移动到当前标记位置</span></span><br><span class="line">    <span class="keyword">int</span> tempNum = numArray[m];</span><br><span class="line">    numArray[m] = numArray[right];</span><br><span class="line">    numArray[right] = tempNum;</span><br><span class="line">    <span class="comment">// 分别对数组左右两侧再次进行排序</span></span><br><span class="line">    QuickSort(numArray, left, m - <span class="number">1</span>);</span><br><span class="line">    QuickSort(numArray, m + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>快速排序算法复杂度为 $O(n\log(n))，相比前面的排序在时间复杂度上有了优化</li></ul><h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2><ul><li>将数组分为两部分，分别对该两部分进行排序，再将这两部分合并为排序好的一部分</li><li>某种程度上与快速排序相同，排序的实现跟直观一些</li><li>相对于快速排序，归并排序额外申请了内存空间，将消耗更多的内存资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] numArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">       <span class="keyword">if</span> (left == right)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;numArray[left]&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span>[] leftArr = mergeSort(numArray, left, mid); <span class="comment">//左有序数组</span></span><br><span class="line">       <span class="keyword">int</span>[] rightArr = mergeSort(numArray, mid + <span class="number">1</span>, right); <span class="comment">//右有序数组</span></span><br><span class="line">       <span class="keyword">int</span>[] newNum = <span class="keyword">new</span> <span class="keyword">int</span>[leftArr.length + rightArr.length]; <span class="comment">//新有序数组</span></span><br><span class="line">       <span class="keyword">int</span> m = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) &#123;</span><br><span class="line">           newNum[m++] = leftArr[i] &lt; rightArr[j] ? leftArr[i++] : rightArr[j++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; leftArr.length)</span><br><span class="line">           newNum[m++] = leftArr[i++];</span><br><span class="line">       <span class="keyword">while</span> (j &lt; rightArr.length)</span><br><span class="line">           newNum[m++] = rightArr[j++];</span><br><span class="line">       <span class="keyword">return</span> newNum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>归并排序可以视为另一种形式的 快速排序，其算法复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>可以仅对原数组进行修改来实现归并排序，我尝试了下，太麻烦没有解决，所有直接 copy 了现成的代码</li></ul><h2 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h2><ul><li>快速排序、归并排序、希尔排序 均采用了 先对数组的部分进行排序，在对整个数组进行排序的策略</li><li>选取指定间隔长度，将数组内相同间隔长度的数分为一组，对该组内数字进行排序操作</li><li>不断减少间隔长度，重复分组并对组内数字进行排序，直到间隔减少至0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] numArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = numArray.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = length; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="comment">// 每组使用插入排序实现排序效果, 可以在复习下插入排序最好的实现方式</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j - gap &gt;= <span class="number">0</span> &amp;&amp; numArray[j] &lt; numArray[j - gap]; j -= gap) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tempNum = numArray[j];</span><br><span class="line">                    numArray[j] = numArray[j - gap];</span><br><span class="line">                    numArray[j - gap] = tempNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="计数排序不需要两两比较"><a class="markdownIt-Anchor" href="#计数排序不需要两两比较"></a> 计数排序——不需要两两比较</h2><div class="note info">            <p>计数排序的实现有些门道，所以在此处重点描述。</p>          </div><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理：</h3><ul><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数排序</span><br><span class="line">public static int[] CountSort(int[] numArray) &#123;</span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for (int num : numArray) &#123;</span><br><span class="line">        max &#x3D; Math.max(max, num);</span><br><span class="line">        min &#x3D; Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    int countLength &#x3D; max - min + 1;</span><br><span class="line">    int[] countTable &#x3D; new int[countLength];</span><br><span class="line">    for (int num : numArray) &#123;</span><br><span class="line">        countTable[num - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; countLength; i++) &#123;</span><br><span class="line">        countTable[i] +&#x3D; countTable[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 从后往前遍历原数组，将排序结果写入新数组</span><br><span class="line">    int[] result &#x3D; new int[numArray.length];</span><br><span class="line">    for (int i &#x3D; numArray.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        result[countTable[numArray[i] - min] - 1] &#x3D; numArray[i];</span><br><span class="line">        &#x2F;&#x2F; 这个 -- 可是有大学问的</span><br><span class="line">        countTable[numArray[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面的话&quot;&gt;&lt;/a&gt; 写在前面的话&lt;/h1&gt;
&lt;p&gt;目前无论哪种语言都已经提供了排序的接口，我们甚至可以自己定义比对函数实现排序功能。但是奈何排序是面试的高发题，不整理下我
      
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="知识总结" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="排序总结" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>使用第三方脚本为butterfly主题添加背景音乐</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/31/Hexo%E9%9F%B3%E4%B9%90%E6%8F%92%E4%BB%B6/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/31/Hexo%E9%9F%B3%E4%B9%90%E6%8F%92%E4%BB%B6/</id>
    <published>2020-07-31T06:34:55.000Z</published>
    <updated>2020-07-31T06:34:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>起先，我也是看到别人的博客才萌发了自己搭建博客的想法，说实话，博客带有音乐播放器让人感觉非常酷炫，所以我也尝试在博客中添加播放器。</p><div class="note default">            <p>butterfly 教程中提到，个人博客要到百度、360之类的搜索引擎网站提交备案。猜测没有备案的博客网站是不会被搜索引擎收录的。想要被搜索引擎检索到，就尝试备案一下吧</p>          </div><h2 id="使用-hexo-tag-aplayer-插件"><a class="markdownIt-Anchor" href="#使用-hexo-tag-aplayer-插件"></a> 使用 hexo-tag-aplayer 插件</h2><p>按照 butterfly 教程提示去安装 hexo-tag-aplayer 插件后，按照插件教程添加配置信息，运行后发现并没有出现播放器😂</p><p>作为前端萌新，放弃了使用 aplayer音乐插件，转而寻找新的方法</p><h2 id="使用第三方播放器"><a class="markdownIt-Anchor" href="#使用第三方播放器"></a> 使用第三方播放器</h2><p><a href="https://blog.csdn.net/weixin_43350051/article/details/106179633" target="_blank" rel="noopener">一篇博客搞定背景音乐</a></p><p>通过百度找到了更好的解决方案，原文如上。</p><p>与作者不同的是，我使用了作者提到的一款免费的网页播放器 —— 梨花带雨播放器 (好奇怪的名字)</p><p><a href="https://music.m0x.cn/index/home/index.html" target="_blank" rel="noopener">梨花带雨播放器官网</a></p><p>具体使用方法就比较简单了，在该主页注册、创建播放器后，将播放器实现代码 clone 到配置文件的 bottom 下即可：</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C63026%5CDesktop%5C%E6%B7%BB%E5%8A%A0%E6%92%AD%E6%94%BE%E5%99%A8.png" alt="添加播放器" /></p><h2 id="遇到的小问题"><a class="markdownIt-Anchor" href="#遇到的小问题"></a> 遇到的小问题</h2><p>网易云内有些歌曲需要 VIP 权限才能播放，那么能不能通过手动添加自己上传的VIP歌曲来播放VIP音乐呢？</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200731152824.png" alt="TIM截图20200731152824" /></p><ul><li>通过 QQ音乐购买单曲下载 MP3资源</li><li>通过Gitee仓库上传该资源，同时上传对应的专辑封面</li><li>添加歌曲</li></ul><div class="note default">            <p>注意对应 的 MP3资源应该跟博客在同一仓库内，否则会因为跨域访问报错：无法加载指定资源</p>          </div><h1 id="写在后面的话"><a class="markdownIt-Anchor" href="#写在后面的话"></a> 写在后面的话</h1><p>经过实际使用，发现该网站提供的播放器有概率无法加载资源，且加载速度很慢，因此推荐使用下面的播放器：</p><p><a href="https://myhkw.cn/" target="_blank" rel="noopener">明月浩空播放器 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面的话&quot;&gt;&lt;/a&gt; 写在前面的话&lt;/h1&gt;
&lt;p&gt;起先，我也是看到别人的博客才萌发了自己搭建博客的想法，说实话，博客带有音乐播放器让人感觉非常酷炫，所以我也尝试在博客中添
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>树结构两三事</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/30/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/30/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-30T09:29:28.000Z</published>
    <updated>2020-07-30T09:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>树结构在编程、算法中占有很重要的地位，树相关问题包括二叉树、红黑树、前序后序中序遍历、最大堆最小堆等等。在此对树结构问题做个总结。</p><h1 id="前序-后序-中序遍历相关问题"><a class="markdownIt-Anchor" href="#前序-后序-中序遍历相关问题"></a> 前序、后序、中序遍历相关问题</h1><h2 id="相关知识"><a class="markdownIt-Anchor" href="#相关知识"></a> 相关知识：</h2><ul><li>前序遍历： 先访问根节点，再访问左子节点，最后访问右子节点。</li><li>中序遍历： 先访问左子节点，在访问根节点，最后访问右子节点。</li><li>后序遍历： 先访问左子节点，在访问右子节点，最后访问根节点。</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    10</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  6    14</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">4   8 12 16</span><br><span class="line"></span><br><span class="line">前序遍历： 10 6 4 8 14 12 16</span><br><span class="line">中序遍历： 4 6 8 10 12 14 16</span><br><span class="line">后序遍历： 4 8 6 12 16 14 10</span><br></pre></td></tr></table></figure><div class="note info flat"><p>简单应用： 通过中序遍历转 前序/后序 计算 算术表达式的值</p></div><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li>掌握前序、后序、中序遍历的递归、迭代实现</li><li>知道前序、后序、中序遍历的意义，可以对其简单应用</li><li>可以通过三者之二还原树结构</li></ul><h2 id="问题一二叉树展开为链表"><a class="markdownIt-Anchor" href="#问题一二叉树展开为链表"></a> 问题一：二叉树展开为链表</h2><h3 id="114-二叉树展开为链表"><a class="markdownIt-Anchor" href="#114-二叉树展开为链表"></a> <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个二叉树，<font color=red><strong>原地</strong></font>将它展开为一个单链表。</p><p>例如，给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure><p>将其展开为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure><h3 id="方法一-前序遍历转列表"><a class="markdownIt-Anchor" href="#方法一-前序遍历转列表"></a> 方法一： 前序遍历转列表</h3><h4 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h4><p>很明显转化过程本质是对树结构的前序遍历，迭代实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果仅仅是前序遍历 肯定不符合题目要求的</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack();</span><br><span class="line">        nodeStack.add(root);</span><br><span class="line">        TreeNode buffNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nodeStack.isEmpty()) &#123;</span><br><span class="line">            buffNode = nodeStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(buffNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nodeStack.add(buffNode.right);</span><br><span class="line">                buffNode.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(buffNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeStack.add(buffNode.left);</span><br><span class="line">                buffNode.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!nodeStack.isEmpty())&#123;</span><br><span class="line">                buffNode.right = nodeStack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="残留的问题"><a class="markdownIt-Anchor" href="#残留的问题"></a> 残留的问题：</h4><ul><li>题干中存在额外要求： “原地” 的。</li><li>时间复杂度、空间复杂度均为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="方法二-寻找前驱节点"><a class="markdownIt-Anchor" href="#方法二-寻找前驱节点"></a> 方法二： 寻找前驱节点</h3><h4 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h4><ul><li>通过观察可以发现 对于任何一个节点，其右子节点在转化后位于其左子树的最右节点之后。根据思路编写实现代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode buffNode = root;</span><br><span class="line">    <span class="keyword">while</span>(buffNode != <span class="keyword">null</span> &amp;&amp; hasChildNode(root)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(buffNode.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(buffNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode fatherNode = rightMaxNode(buffNode.left);</span><br><span class="line">                fatherNode.right = buffNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">            buffNode.right = buffNode.left;</span><br><span class="line">            buffNode.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffNode = buffNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">rightMaxNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasChildNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.left != <span class="keyword">null</span> || node.right != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>递归实现方式更加直观</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">flatten(root.left);</span><br><span class="line">flatten(root.right);</span><br><span class="line">TreeNode bufferNode = root.right;</span><br><span class="line">root.right = root.left;</span><br><span class="line">root.left = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 此时的 root.right 对应原节点的左子节点</span></span><br><span class="line"><span class="keyword">while</span>(root.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">root =root.right;</span><br><span class="line">&#125;</span><br><span class="line">root.right = bufferNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="问题二重建二叉树"><a class="markdownIt-Anchor" href="#问题二重建二叉树"></a> 问题二：重建二叉树</h2><h3 id="剑指-offer-07-重建二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-07-重建二叉树"></a> <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></h3><p>Difficulty: <strong>中等</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 5000</code></p><p><strong>注意</strong>：本题与主站 105 题重复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有点难搞，等等先😂</span><br></pre></td></tr></table></figure><h2 id="问题三判断平衡二叉树"><a class="markdownIt-Anchor" href="#问题三判断平衡二叉树"></a> 问题三：判断平衡二叉树</h2><h3 id="110-平衡二叉树"><a class="markdownIt-Anchor" href="#110-平衡二叉树"></a> <a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h3><p>Difficulty: <strong>简单</strong></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树_每个节点 _的左右两个子树的高度差的绝对值不超过1。</p></blockquote><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><h3 id="方法一-我的方法概念未理解导致错误"><a class="markdownIt-Anchor" href="#方法一-我的方法概念未理解导致错误"></a> 方法一： 我的方法（概念未理解导致错误）</h3><h4 id="思路分析-3"><a class="markdownIt-Anchor" href="#思路分析-3"></a> 思路分析：</h4><p>我<font color=purple><strong>印象</strong></font>中平衡二叉树的定义为：<font color=blue><strong>叶子节点的最大深度只比最小深度多一</strong></font>,导致编码错误。</p><p>按照我的理解，设计编码思路如下：</p><ul><li>通过遍历获取所有叶子节点的深度，并按照从深到浅的顺序依次向上返回</li><li>返回内容为：当前子树的最大深度与最浅深度</li><li>返回父节点时，对两者进行比较，将子树的最大深度作为自己的最大深度；子树的最浅深度作为自己的最浅深度</li><li>返回根节点时，比较最大深度与最浅深度，差值大于一则不为完全平衡二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断方法很简单，最浅不完全层与最深树节点差值超过2，即为不完全树</span></span><br><span class="line">        <span class="comment">//  递归获取子树的深度差，差值大于 1 则认为是不完全子树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = deepPlus(root, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(result[<span class="number">0</span>] - result[<span class="number">1</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是自上而下的遍历，则必须返回才能判断结果</span></span><br><span class="line">    <span class="comment">// 很明显做了很多无关的判断，使用循环可以通过判断解决该问题，但是算了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] deepPlus(TreeNode node, <span class="keyword">int</span> deep, <span class="keyword">int</span> minDeep, <span class="keyword">boolean</span> isMinGet) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;deep, minDeep&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deepPlus(node.right, deep+<span class="number">1</span>, minDeep, <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deepPlus(node.left, deep+<span class="number">1</span>, minDeep, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minDepth = minDeep;</span><br><span class="line">        <span class="keyword">if</span>(!isMinGet) &#123;</span><br><span class="line">            minDepth += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] leftDeep = deepPlus(node.left, deep + <span class="number">1</span>, minDepth, isMinGet);</span><br><span class="line">        <span class="keyword">int</span>[] rightDeep = deepPlus(node.right, deep + <span class="number">1</span>, minDepth, isMinGet);</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Math.max(leftDeep[<span class="number">0</span>], rightDeep[<span class="number">0</span>]), Math.min(leftDeep[<span class="number">1</span>], rightDeep[<span class="number">1</span>])&#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析：</h4><ul><li>很明显从逻辑上遍历了所有的节点</li><li>(仅限于当前对完全二叉树的认知基础上)可以通过循环遍历更早的对树的性质进行判断</li><li>时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> , 空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="完全二叉树定义"><a class="markdownIt-Anchor" href="#完全二叉树定义"></a> 完全二叉树定义：</h2><h4 id="百度百科"><a class="markdownIt-Anchor" href="#百度百科"></a> 百度百科：</h4><p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><h2 id="平衡二叉树定义"><a class="markdownIt-Anchor" href="#平衡二叉树定义"></a> 平衡二叉树定义：</h2><h4 id="百度百科-2"><a class="markdownIt-Anchor" href="#百度百科-2"></a> 百度百科：</h4><p>平衡树(Balance Tree，BT) 指的是，<font color=purple><strong>任意节点的子树的高度差都小于等于1</strong></font>。常见的符合平衡树的有，B树（多路平衡搜索树）、AVL树（二叉平衡搜索树）等。平衡树可以完成集合的一系列操作, 时间复杂度和空间复杂度相对于“2-3树”要低，在完成集合的一系列操作中始终保持平衡，为大型数据库的组织、索引提供了一条新的途径。</p><div class="note info flat"><p>原来是我搞混了 <strong>平衡二叉树</strong> 与 <strong>完全二叉树</strong> 😂😂</p></div><h3 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二：</h3><p><a href="https://www.modb.pro/db/11333" target="_blank" rel="noopener">https://www.modb.pro/db/11333</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面的话&quot;&gt;&lt;/a&gt; 写在前面的话&lt;/h1&gt;
&lt;p&gt;树结构在编程、算法中占有很重要的地位，树相关问题包括二叉树、红黑树、前序后序中序遍历、最大堆最小堆等等。在此对树结构问题
      
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="知识总结" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/leetcode/"/>
    
      <category term="树结构" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题Day 4】 数学方法解题——整数拆分</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%204/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%204/</id>
    <published>2020-07-28T05:26:03.000Z</published>
    <updated>2020-07-28T05:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="343-整数拆分"><a class="markdownIt-Anchor" href="#343-整数拆分"></a> <a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 你可以假设 _n _不小于 2 且不大于 58。</p><h2 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h2><p>本题其实并不难，但是因为勾起了我对数学的回忆，还是认真解决下，所谓不忘初心嘛</p><p>挺后悔高中的笔记没有留着😂</p><p>记得高中时看到一本书上说“高中可能是脑力的巅峰了” 我还不信，现在信了呵呵。</p><h2 id="方法一数学分析"><a class="markdownIt-Anchor" href="#方法一数学分析"></a> 方法一：数学分析</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><h4 id="麻烦的思路"><a class="markdownIt-Anchor" href="#麻烦的思路"></a> 麻烦的思路：</h4><ul><li>根据我们对均值不等式的印象，很容易判断出将数字等分时能取到最大值，本题的关键变成了将数字分为几份时，取到该最大值。</li><li>考虑n阶不等式，根据不等式性质我们知道当 将 sum 等分时取到最大值，sum为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><mi>a</mi><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum(a1,an)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>能最终得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">a/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">n</span></span></span></span> 等于 e 时取最大值，但是整个过程很乱，证明不等式太复杂</li></ul><h4 id="清晰的思路"><a class="markdownIt-Anchor" href="#清晰的思路"></a> 清晰的思路</h4><ul><li>换一种思路，既然我们一开始就知道将 sum 等分时能取到最大值，那不妨设当sum分为 x 时，乘积最大。(事实上我还是偏向于设分为x份)，解题过程如下：</li></ul><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C63026%5CDesktop%5C%E6%8E%A8%E5%AF%BC%E5%87%BD%E6%95%B0%E6%9C%80%E5%A4%A7%E5%80%BC.jpg" alt="推导函数最大值" /></p><h3 id="对应代码如下"><a class="markdownIt-Anchor" href="#对应代码如下"></a> 对应代码如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据结论越逼近f(3)结果越大，所以余1视为4，余2保留</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> number = n / <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">2</span> ? (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, number + <span class="number">1</span>) * left : (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, number) * (<span class="number">3</span> + left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>对于本题，题解中给出的算法复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 也就是说计算次方的算法开销为常数。</li><li>对于 Java Math.pow() 具体实现方式不再进行分析 (毕竟属于无关紧要的部分)</li><li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="方法二动态规划"><a class="markdownIt-Anchor" href="#方法二动态规划"></a> 方法二：动态规划</h2><h3 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h3><p>类似 【每日一题Day 1】分割数组最大值(本题因为数据特征明显所以存在更好的解法);</p><ul><li><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 是对数字 n 的最佳分割</p></li><li><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，很明显只能分成一份，根据题目要求： 0 * 1 = 0；</p></li><li><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>，其可以表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(1, n)dp[i] * (n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>   (max(1,n) 表示从1到n，后面方程的最大值)</p></li><li><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>时，存在异常情况，此使分为两份更正确。因此必须考虑 i * (n - i) 的情况</p></li></ul><div class="note warning">            <p>为什么要考虑 i * (n - i) 的情况？ 我认为是因为本题默认最少分割为两块，对于动态变换公式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mi>i</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[n] = dp[i]*(n - i) i\in(1,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>， 其足以遍历所有分割份数大于2的情况，但是由于默认起始位置为 2 的原因，并不能遍历分割数为2的情况，因此需要额外判断 i * (n -i)</p>          </div><h3 id="实现代码如下"><a class="markdownIt-Anchor" href="#实现代码如下"></a> 实现代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resultBuffer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            resultBuffer = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k&lt;i;k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> midBuffer = Math.max(k * (i-k), result[k] * (i -k));              </span><br><span class="line">                resultBuffer = Math.max(resultBuffer, midBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = resultBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="额外的优化"><a class="markdownIt-Anchor" href="#额外的优化"></a> 额外的优化</h2><p>该题对应的题解上还对动态转移方程进行了进一步的优化，但实际上其对应的思路有种“知道答案推结果的感觉”，因此不再给出</p><div class="note info">            <p>事实上，我们肯定能证明 对于 n1 &gt; n2, 一定有 n1 分割的次数 大于等于 n2 分割的次数，但是就本题而言，记录分割次数并没有太多必要。</p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;h3 id=&quot;343-整数拆分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#343-整数拆分&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数学分析" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题Day 3】逆向思维——逃离大迷宫</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/</id>
    <published>2020-07-27T14:53:15.000Z</published>
    <updated>2020-07-27T14:53:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p><font color=#FF1493 font = 10><strong>虽然没有做多少题呢，但是我已经发现了，做题，怕的不是没有思路，而是不敢尝试。</strong></font></p><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="1036-逃离大迷宫"><a class="markdownIt-Anchor" href="#1036-逃离大迷宫"></a> <a href="https://leetcode-cn.com/problems/escape-a-large-maze/" target="_blank" rel="noopener">1036. 逃离大迷宫</a></h3><p>Difficulty: <strong>困难</strong></p><p>在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 <code>(x, y)</code>，其中 <code>0 &lt;= x, y &lt; 10^6</code>。</p><p>我们从源方格 <code>source</code> 开始出发，意图赶往目标方格 <code>target</code>。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 <code>blocked</code> 上。</p><p>只有在可以通过一系列的移动到达目标方格时才返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [[0,1],[1,0]], source &#x3D; [0,0], target &#x3D; [0,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">从源方格无法到达目标方格，因为我们无法在网格中移动。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [], source &#x3D; [0,0], target &#x3D; [999999,999999]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">因为没有方格被封锁，所以一定可以到达目标方格。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= blocked.length &lt;= 200</code></li><li><code>blocked[i].length == 2</code></li><li><code>0 &lt;= blocked[i][j] &lt; 10^6</code></li><li><code>source.length == target.length == 2</code></li><li><code>0 &lt;= source[i][j], target[i][j] &lt; 10^6</code></li><li><code>source != target</code></li></ol><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析：</h2><p>本题可以抽象为，能不能通过 blocked 将网格分成互不连通的两部分，且起点与原点分别位于分割线的两侧。进一步观察所给的参数：</p><ul><li>网格大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，基本可以放弃对网格做什么操作了。</li><li>blocked.length 的范围为 [0,200] ，完全在一个可接受的范围内，可以尝试从此入手</li></ul><h2 id="方法一寻找链接原点与终点的路径"><a class="markdownIt-Anchor" href="#方法一寻找链接原点与终点的路径"></a> 方法一：寻找链接原点与终点的路径</h2><p>老实说，该方法我还没看懂，在此贴出对应的链接地址，有兴趣可以试试这种方法😂</p><p><a href="https://leetcode-cn.com/problems/escape-a-large-maze/solution/cong-zhang-ai-wu-dian-blockedru-shou-de-kuai-su-su/" target="_blank" rel="noopener">从障碍物点入手的快速算法</a></p><h2 id="方法二-逆向思维判断是否存在满足题意的路径"><a class="markdownIt-Anchor" href="#方法二-逆向思维判断是否存在满足题意的路径"></a> 方法二： 逆向思维判断是否存在满足题意的路径</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><ul><li><p>提示里提到： 0&lt;= blocked.length &lt;=200; 也就是说圈起来的面积存在最大值。</p></li><li><p>根据抽屉原理，当从该点出发可以达到的面积大于圈起来的面积时，我们可以认为该点一定在圈外。</p></li><li><p>根据以上原理，判断起点终点是否同时在圈内或圈外即可</p></li></ul><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li>注意两点都在圈内的情况</li><li>对边界进行限制（0可以取到 😂）</li></ul><h3 id="代码实现如下"><a class="markdownIt-Anchor" href="#代码实现如下"></a> 代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] aroundArray = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outNumber = <span class="number">19901</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mapLength = <span class="number">1000000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEscapePossible</span><span class="params">(<span class="keyword">int</span>[][] blocked, <span class="keyword">int</span>[] source, <span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 hashmap 管理 blocked，降低检索造成的开销</span></span><br><span class="line">        <span class="keyword">if</span> (blocked.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;String&gt; blockedTable = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] location : blocked) &#123;</span><br><span class="line">            blockedTable.add(changeArrayToString(location));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 200 个点最多限制的格子数目为： 19900，当超出该数目时，意味着超出Block可圈界限</span></span><br><span class="line">        <span class="comment">// 取 19901 作为判断基准</span></span><br><span class="line">        <span class="keyword">return</span> isInBlocked(blockedTable, source, outNumber, changeArrayToString(target)) &amp;&amp; isInBlocked(blockedTable, target, outNumber, changeArrayToString(source));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInBlocked</span><span class="params">(HashSet&lt;String&gt; blockedTable, <span class="keyword">int</span>[] source, <span class="keyword">int</span> limitsNum, String targetStr)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; aroundQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        aroundQueue.add(source);</span><br><span class="line">        <span class="comment">// 记录走过的方格的 哈希表</span></span><br><span class="line">        HashSet&lt;String&gt; walkedSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        walkedSet.add(changeArrayToString(source));</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!aroundQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] node = aroundQueue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aroundArray.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] bufferNode = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                bufferNode[<span class="number">0</span>] = node[<span class="number">0</span>] + aroundArray[i];</span><br><span class="line">                bufferNode[<span class="number">1</span>] = node[<span class="number">1</span>] + aroundArray[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(isInArray(bufferNode[<span class="number">0</span>])&amp;&amp;isInArray(bufferNode[<span class="number">1</span>])) &#123;</span><br><span class="line">                    String locStr = changeArrayToString(bufferNode);</span><br><span class="line">                    <span class="keyword">if</span>((!blockedTable.contains(locStr)) &amp;&amp; (!walkedSet.contains(locStr)))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(locStr.equals(targetStr))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        aroundQueue.add(bufferNode);</span><br><span class="line">                        num++;</span><br><span class="line">                        walkedSet.add(locStr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= limitsNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">changeArrayToString</span><span class="params">(<span class="keyword">int</span>[] location)</span> </span>&#123;</span><br><span class="line">        StringBuilder strBuild = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        strBuild.append(location[<span class="number">0</span>]);</span><br><span class="line">        strBuild.append(<span class="string">","</span>);</span><br><span class="line">        strBuild.append(location[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> strBuild.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(location &gt;= <span class="number">0</span> &amp;&amp; location &lt; mapLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>算法复杂度：</p><ul><li>如我们所见，该算法实际作用域特定情况，我们甚至可以求出他的最大运算次数，所以大概跟复杂度不沾边了😂</li><li>额外声明了两个哈希表，用于存储不能行走的方格</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>编程题不一定用到编程技巧，或者说其实算法更侧重数学</li><li>对于 “是否存在” 问题，多考虑能否通过条件证明其存在，而不是求出该路径</li></ul><h2 id="下面这篇文章侧重于编程技巧"><a class="markdownIt-Anchor" href="#下面这篇文章侧重于编程技巧"></a> 下面这篇文章侧重于编程技巧：</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面的话&quot;&gt;&lt;/a&gt; 写在前面的话&lt;/h1&gt;
&lt;p&gt;&lt;font color=#FF1493 font = 10&gt;&lt;strong&gt;虽然没有做多少题呢，但是我已经发现了，做题，
      
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/leetcode/"/>
    
      <category term="抽屉原理" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题Day 2】 矩阵中的最长递增路径</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/</id>
    <published>2020-07-26T08:07:53.000Z</published>
    <updated>2020-07-26T08:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="329-矩阵中的最长递增路径"><a class="markdownIt-Anchor" href="#329-矩阵中的最长递增路径"></a> <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><h2 id="方法一-记忆化深度优先搜索"><a class="markdownIt-Anchor" href="#方法一-记忆化深度优先搜索"></a> 方法一： 记忆化深度优先搜索</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><p>对于本题很容易找到解题思路：</p><ul><li>找到每个位置可以到达的下个位置（构造了树结构）</li><li>找到构造的树结构所能到达的最大深度</li></ul><p>我们的树结构看起来不那么好构造，但实际上我们需要获得的是树的深度，因此：</p><ul><li>创建额外的空间存储以当前数字为根节点构造的树所能达到的最大深度</li><li>列出动态转移方程： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo>∑</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>a</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(\sum(0, around))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>around 指矩阵的四周</li></ul><p>根据思路编写实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组模拟遍历操作(也可以模拟九宫格，应该可以😂)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] besideList = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 与其在函数外部对 0、null判断，不如交给函数内部判断。 切记切记</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> sizeX = matrix.length;</span><br><span class="line">       <span class="keyword">int</span> sizeY = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] resultDeep = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;sizeX;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sizeY;j++)&#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,i,j,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxDeep;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] resultDeep)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(resultDeep[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;besideList.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> nowX = x + besideList[i];</span><br><span class="line">           <span class="keyword">int</span> nowY = y + besideList[i+<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(!isInArray(nowX,nowY,matrix))&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(matrix[x][y]&lt;matrix[nowX][nowY]) &#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,nowX,nowY,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       resultDeep[x][y] = maxDeep + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 如果返回 boolean ，最好return &#123;逻辑语句&#125; , 而不是通过 if else 返回 true 或 false</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;matrix.length&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><ul><li>时间复杂度分析： O(mn),其中 m 和 n 分别是矩阵的行数和列数。深度优先搜索的时间复杂度是 O(V+E)，其中 V 是节点数，E 是边数。在矩阵中，O(V)=O(mn)。</li><li>空间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。空间复杂度主要取决于缓存和递归调用深度，缓存的空间复杂度是 O(mn)，递归调用深度不会超过 mn。</li></ul><h3 id="遗留问题"><a class="markdownIt-Anchor" href="#遗留问题"></a> 遗留问题</h3><p><font color=#FF4500><strong> 对深度优先算法、广度优先算法没有做到掌握，将在之后的篇章给出进一步总结。</strong></font></p><h2 id="方法二拓扑排序动态规划"><a class="markdownIt-Anchor" href="#方法二拓扑排序动态规划"></a> 方法二：拓扑排序（动态规划）</h2><h2 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h2><p>类比寻找二叉树深度的算法，其本质上是 DFS 的循环实现，本题的难点在于如何找到循环的依据：</p><ul><li><p>将数组看作有向图，寻找出度为0的点（即最大点）</p></li><li><p>从所有出度为0的点进行广度优先搜索，并更新出度值，将新的出度为0的点加入搜索队列内</p></li><li><p>搜索总层数即为矩阵中最长递增路径的长度</p><p><font color=#C71585><strong>懒了没有编写对应的实现代码，直接贴了题解</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 太长了不想贴，回头自己写个再补上吧</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析：</h3><p>与方法一相同，但是实现上复杂了许多</p><h3 id="遗留问题-2"><a class="markdownIt-Anchor" href="#遗留问题-2"></a> 遗留问题：</h3><ul><li><p>「方法一」中使用了记忆化存储和深度优先搜索，这里的深度优先搜索可以替换成广度优先搜索吗？</p></li><li><p>「方法二」中基于拓扑排序对排序后的有向无环图做了层次遍历，如果没有拓扑排序直接进行广度优先搜索会发生什么？</p></li><li><p>「方法二」中如果不使用拓扑排序，而是直接按照矩阵中元素的值从大到小进行排序，并依此顺序进行状态转移，那么可以得到正确的答案吗？如果是从小到大进行排序呢？</p></li><li><p>「变式」给定一个整数矩阵，找出符合以下条件的路径的数量：该路径严格递增，切长度至少为3.矩阵边长最大为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，答案对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 取模。其他条件与题目相同。思考对应解法</p></li></ul><h4 id="答案见如下文章"><a class="markdownIt-Anchor" href="#答案见如下文章"></a> 答案见如下文章：</h4><h4 id="文章部分思路借鉴"><a class="markdownIt-Anchor" href="#文章部分思路借鉴"></a> 文章部分思路借鉴：</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/" target="_blank" rel="noopener">leetcode 官方解答</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;h3 id=&quot;329-矩阵中的最长递增路径&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#329-矩阵中的最
      
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="深度优先遍历" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题Day 1】 分割数组的最大值</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/</id>
    <published>2020-07-25T12:35:20.000Z</published>
    <updated>2020-07-25T12:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="410-分割数组的最大值"><a class="markdownIt-Anchor" href="#410-分割数组的最大值"></a> <a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 _m _个非空的连续子数组。设计一个算法使得这 _m _个子数组各自和的最大值最小。</p><p><strong>注意:</strong><br />数组长度 _n _满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><h1 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答"></a> 题目解答</h1><h2 id="方法一-动态规划"><a class="markdownIt-Anchor" href="#方法一-动态规划"></a> 方法一： 动态规划</h2><h3 id="分析过程"><a class="markdownIt-Anchor" href="#分析过程"></a> 分析过程</h3><h4 id="错误的状态转移方程"><a class="markdownIt-Anchor" href="#错误的状态转移方程"></a> 错误的状态转移方程</h4><p>实不相瞒，我第一眼看到该题时，思考的方法为：</p><p>创建 m 个空数组，每次将新数字添加到当前数字之和最小的空数组中。很明显这种方法是不正确的。（脑瘫行为😂）</p><h4 id="正确的状态转移方程"><a class="markdownIt-Anchor" href="#正确的状态转移方程"></a> 正确的状态转移方程</h4><p>题目中提到两个变量，连续子数组个数 m，数组内数字个数n。 我们假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示将前 i 个数字按照要求分为 j 份所能得到的最大连续和的最小值，考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，枚举 k 属于 1~j，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 可以视为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[k][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_k^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span> 中较大者，详细描述如图：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC.jpg" alt="分割数组最大值" /></p><p>根据动态转移方程编写对应代码：</p><p>值得注意的是，除了考虑 i &lt; j 的情况，还要注意i 、j 为 0 的初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">// 需要预留(0,0) 的空间，否则会因为初始的 MAX_VALUE 导致结果出错</span></span><br><span class="line">        <span class="keyword">int</span>[][] results = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=length;i++) &#123;</span><br><span class="line">            Arrays.fill(results[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免结果被MAX_VALUE</span></span><br><span class="line">        results[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化前n项和,用于快速计算连续序列的和</span></span><br><span class="line">        <span class="keyword">int</span>[] preArrayResult = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            preArrayResult[i+<span class="number">1</span>] = preArrayResult[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过三层循环 得到f[i][j] 的所有结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i, m); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    <span class="comment">// 根据递推公式转换而来</span></span><br><span class="line">                    results[i][j] = Math.min(results[i][j], Math.max(results[k][j - <span class="number">1</span>], preArrayResult[i] - preArrayResult[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面的循环同理</span></span><br><span class="line">        <span class="comment">// for(int j = 1;j&lt;=m;j++) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int i=0;i&lt;=length; i++)&#123;</span></span><br><span class="line">        <span class="comment">//         for (int k = 0; k &lt; i; k++) &#123;</span></span><br><span class="line">        <span class="comment">//             results[i][j] = Math.min(results[i][j], Math.max(results[k][j - 1], preArrayResult[i] - preArrayResult[k]));</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> results[length][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="方法二-二分查找-贪心"><a class="markdownIt-Anchor" href="#方法二-二分查找-贪心"></a> 方法二： 二分查找 + 贪心</h2><p>原理很简单，很明显我们的答案在一个可以预测的范围内：其下界大于所有数字中最大的数。其上界小于所有数字的和。即：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\in(max(a),\sum(a))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>对于排序的数组内寻找符合条件的值，自然使用二分法，配合贪心算法判断是否存在分割方法满足要求即可。</p><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><p><font color=#C71585><strong>这其实是我个人的问题，因为不常写二分查找算法的缘故，这题我加了很多判断条件才算解决</strong></font></p><ul><li>本题可以取下界却不能取上界（下界可能为问题的解）</li><li>修改边界时，对于可取边界要 +1 ： left = mid + 1;</li><li>为了避免整数溢出，最好使用 (right - left) / 2 + left 计算 mid  （我将 mid 设为了 double 类型）</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>不难判断本题的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(sum - maxn))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>类似穷举法的题目还有很多，比如一定范围内质数、符合某项规定的数字等等。可以考虑该解法减少运算量。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/1595702409237.jpeg" alt="img" /></p>]]></content>
    
    <summary type="html">
    
      动态规划、二分查找、贪心相关
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二分查找" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="贪心算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
