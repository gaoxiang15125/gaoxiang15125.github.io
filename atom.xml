<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小的毛毛虫</title>
  <icon>https://www.gravatar.com/avatar/d1ef88200293f35641bebedc91aa7821</icon>
  <subtitle>小小的毛毛虫，也想要破茧成蝶</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/"/>
  <updated>2020-07-27T14:53:15.000Z</updated>
  <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/</id>
  
  <author>
    <name>gaoxiang</name>
    <email>630268696@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【每日一题Day3】逆向思维——逃离大迷宫</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/</id>
    <published>2020-07-27T14:53:15.000Z</published>
    <updated>2020-07-27T14:53:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p><font color=#FF1493 font = 10><strong>虽然没有做多少题呢，但是我已经发现了，做题，怕的不是没有思路，而是不敢尝试。</strong></font></p><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="1036-逃离大迷宫"><a class="markdownIt-Anchor" href="#1036-逃离大迷宫"></a> <a href="https://leetcode-cn.com/problems/escape-a-large-maze/" target="_blank" rel="noopener">1036. 逃离大迷宫</a></h3><p>Difficulty: <strong>困难</strong></p><p>在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 <code>(x, y)</code>，其中 <code>0 &lt;= x, y &lt; 10^6</code>。</p><p>我们从源方格 <code>source</code> 开始出发，意图赶往目标方格 <code>target</code>。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 <code>blocked</code> 上。</p><p>只有在可以通过一系列的移动到达目标方格时才返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [[0,1],[1,0]], source &#x3D; [0,0], target &#x3D; [0,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">从源方格无法到达目标方格，因为我们无法在网格中移动。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [], source &#x3D; [0,0], target &#x3D; [999999,999999]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">因为没有方格被封锁，所以一定可以到达目标方格。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= blocked.length &lt;= 200</code></li><li><code>blocked[i].length == 2</code></li><li><code>0 &lt;= blocked[i][j] &lt; 10^6</code></li><li><code>source.length == target.length == 2</code></li><li><code>0 &lt;= source[i][j], target[i][j] &lt; 10^6</code></li><li><code>source != target</code></li></ol><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析：</h2><p>本题可以抽象为，能不能通过 blocked 将网格分成互不连通的两部分，且起点与原点分别位于分割线的两侧。进一步观察所给的参数：</p><ul><li>网格大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，基本可以放弃对网格做什么操作了。</li><li>blocked.length 的范围为 [0,200] ，完全在一个可接受的范围内，可以尝试从此入手</li></ul><h2 id="方法一寻找链接原点与终点的路径"><a class="markdownIt-Anchor" href="#方法一寻找链接原点与终点的路径"></a> 方法一：寻找链接原点与终点的路径</h2><p>老实说，该方法我还没看懂，在此贴出对应的链接地址，有兴趣可以试试这种方法😂</p><p><a href="https://leetcode-cn.com/problems/escape-a-large-maze/solution/cong-zhang-ai-wu-dian-blockedru-shou-de-kuai-su-su/" target="_blank" rel="noopener">从障碍物点入手的快速算法</a></p><h2 id="方法二-逆向思维判断是否存在满足题意的路径"><a class="markdownIt-Anchor" href="#方法二-逆向思维判断是否存在满足题意的路径"></a> 方法二： 逆向思维判断是否存在满足题意的路径</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><ul><li><p>提示里提到： 0&lt;= blocked.length &lt;=200; 也就是说圈起来的面积存在最大值。</p></li><li><p>根据抽屉原理，当从该点出发可以达到的面积大于圈起来的面积时，我们可以认为该点一定在圈外。</p></li><li><p>根据以上原理，判断起点终点是否同时在圈内或圈外即可</p></li></ul><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li>注意两点都在圈内的情况</li><li>对边界进行限制（0可以取到 😂）</li></ul><h3 id="代码实现如下"><a class="markdownIt-Anchor" href="#代码实现如下"></a> 代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] aroundArray = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outNumber = <span class="number">19901</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mapLength = <span class="number">1000000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEscapePossible</span><span class="params">(<span class="keyword">int</span>[][] blocked, <span class="keyword">int</span>[] source, <span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 hashmap 管理 blocked，降低检索造成的开销</span></span><br><span class="line">        <span class="keyword">if</span> (blocked.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;String&gt; blockedTable = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] location : blocked) &#123;</span><br><span class="line">            blockedTable.add(changeArrayToString(location));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 200 个点最多限制的格子数目为： 19900，当超出该数目时，意味着超出Block可圈界限</span></span><br><span class="line">        <span class="comment">// 取 19901 作为判断基准</span></span><br><span class="line">        <span class="keyword">return</span> isInBlocked(blockedTable, source, outNumber, changeArrayToString(target)) &amp;&amp; isInBlocked(blockedTable, target, outNumber, changeArrayToString(source));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInBlocked</span><span class="params">(HashSet&lt;String&gt; blockedTable, <span class="keyword">int</span>[] source, <span class="keyword">int</span> limitsNum, String targetStr)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; aroundQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        aroundQueue.add(source);</span><br><span class="line">        <span class="comment">// 记录走过的方格的 哈希表</span></span><br><span class="line">        HashSet&lt;String&gt; walkedSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        walkedSet.add(changeArrayToString(source));</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!aroundQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] node = aroundQueue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aroundArray.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] bufferNode = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                bufferNode[<span class="number">0</span>] = node[<span class="number">0</span>] + aroundArray[i];</span><br><span class="line">                bufferNode[<span class="number">1</span>] = node[<span class="number">1</span>] + aroundArray[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(isInArray(bufferNode[<span class="number">0</span>])&amp;&amp;isInArray(bufferNode[<span class="number">1</span>])) &#123;</span><br><span class="line">                    String locStr = changeArrayToString(bufferNode);</span><br><span class="line">                    <span class="keyword">if</span>((!blockedTable.contains(locStr)) &amp;&amp; (!walkedSet.contains(locStr)))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(locStr.equals(targetStr))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        aroundQueue.add(bufferNode);</span><br><span class="line">                        num++;</span><br><span class="line">                        walkedSet.add(locStr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= limitsNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">changeArrayToString</span><span class="params">(<span class="keyword">int</span>[] location)</span> </span>&#123;</span><br><span class="line">        StringBuilder strBuild = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        strBuild.append(location[<span class="number">0</span>]);</span><br><span class="line">        strBuild.append(<span class="string">","</span>);</span><br><span class="line">        strBuild.append(location[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> strBuild.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(location &gt;= <span class="number">0</span> &amp;&amp; location &lt; mapLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>算法复杂度：</p><ul><li>如我们所见，该算法实际作用域特定情况，我们甚至可以求出他的最大运算次数，所以大概跟复杂度不沾边了😂</li><li>额外声明了两个哈希表，用于存储不能行走的方格</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>编程题不一定用到编程技巧，或者说其实算法更侧重数学</li><li>对于 “是否存在” 问题，多考虑能否通过条件证明其存在，而不是求出该路径</li></ul><h2 id="下面这篇文章侧重于编程技巧"><a class="markdownIt-Anchor" href="#下面这篇文章侧重于编程技巧"></a> 下面这篇文章侧重于编程技巧：</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面的话&quot;&gt;&lt;/a&gt; 写在前面的话&lt;/h1&gt;
&lt;p&gt;&lt;font color=#FF1493 font = 10&gt;&lt;strong&gt;虽然没有做多少题呢，但是我已经发现了，做题，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【每日一题Day 2】 矩阵中的最长递增路径</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/</id>
    <published>2020-07-26T08:07:53.000Z</published>
    <updated>2020-07-26T08:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="329-矩阵中的最长递增路径"><a class="markdownIt-Anchor" href="#329-矩阵中的最长递增路径"></a> <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><h2 id="方法一-记忆化深度优先搜索"><a class="markdownIt-Anchor" href="#方法一-记忆化深度优先搜索"></a> 方法一： 记忆化深度优先搜索</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><p>对于本题很容易找到解题思路：</p><ul><li>找到每个位置可以到达的下个位置（构造了树结构）</li><li>找到构造的树结构所能到达的最大深度</li></ul><p>我们的树结构看起来不那么好构造，但实际上我们需要获得的是树的深度，因此：</p><ul><li>创建额外的空间存储以当前数字为根节点构造的树所能达到的最大深度</li><li>列出动态转移方程： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo>∑</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>a</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(\sum(0, around))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>around 指矩阵的四周</li></ul><p>根据思路编写实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组模拟遍历操作(也可以模拟九宫格，应该可以😂)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] besideList = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 与其在函数外部对 0、null判断，不如交给函数内部判断。 切记切记</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> sizeX = matrix.length;</span><br><span class="line">       <span class="keyword">int</span> sizeY = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] resultDeep = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;sizeX;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sizeY;j++)&#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,i,j,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxDeep;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] resultDeep)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(resultDeep[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;besideList.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> nowX = x + besideList[i];</span><br><span class="line">           <span class="keyword">int</span> nowY = y + besideList[i+<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(!isInArray(nowX,nowY,matrix))&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(matrix[x][y]&lt;matrix[nowX][nowY]) &#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,nowX,nowY,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       resultDeep[x][y] = maxDeep + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 如果返回 boolean ，最好return &#123;逻辑语句&#125; , 而不是通过 if else 返回 true 或 false</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;matrix.length&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><ul><li>时间复杂度分析： O(mn),其中 m 和 n 分别是矩阵的行数和列数。深度优先搜索的时间复杂度是 O(V+E)，其中 V 是节点数，E 是边数。在矩阵中，O(V)=O(mn)。</li><li>空间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。空间复杂度主要取决于缓存和递归调用深度，缓存的空间复杂度是 O(mn)，递归调用深度不会超过 mn。</li></ul><h3 id="遗留问题"><a class="markdownIt-Anchor" href="#遗留问题"></a> 遗留问题</h3><p><font color=#FF4500><strong> 对深度优先算法、广度优先算法没有做到掌握，将在之后的篇章给出进一步总结。</strong></font></p><h2 id="方法二拓扑排序动态规划"><a class="markdownIt-Anchor" href="#方法二拓扑排序动态规划"></a> 方法二：拓扑排序（动态规划）</h2><h2 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h2><p>类比寻找二叉树深度的算法，其本质上是 DFS 的循环实现，本题的难点在于如何找到循环的依据：</p><ul><li><p>将数组看作有向图，寻找出度为0的点（即最大点）</p></li><li><p>从所有出度为0的点进行广度优先搜索，并更新出度值，将新的出度为0的点加入搜索队列内</p></li><li><p>搜索总层数即为矩阵中最长递增路径的长度</p><p><font color=#C71585><strong>懒了没有编写对应的实现代码，直接贴了题解</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 太长了不想贴，回头自己写个再补上吧</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析：</h3><p>与方法一相同，但是实现上复杂了许多</p><h3 id="遗留问题-2"><a class="markdownIt-Anchor" href="#遗留问题-2"></a> 遗留问题：</h3><ul><li><p>「方法一」中使用了记忆化存储和深度优先搜索，这里的深度优先搜索可以替换成广度优先搜索吗？</p></li><li><p>「方法二」中基于拓扑排序对排序后的有向无环图做了层次遍历，如果没有拓扑排序直接进行广度优先搜索会发生什么？</p></li><li><p>「方法二」中如果不使用拓扑排序，而是直接按照矩阵中元素的值从大到小进行排序，并依此顺序进行状态转移，那么可以得到正确的答案吗？如果是从小到大进行排序呢？</p></li><li><p>「变式」给定一个整数矩阵，找出符合以下条件的路径的数量：该路径严格递增，切长度至少为3.矩阵边长最大为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，答案对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 取模。其他条件与题目相同。思考对应解法</p></li></ul><h4 id="答案见如下文章"><a class="markdownIt-Anchor" href="#答案见如下文章"></a> 答案见如下文章：</h4><h4 id="文章部分思路借鉴"><a class="markdownIt-Anchor" href="#文章部分思路借鉴"></a> 文章部分思路借鉴：</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/" target="_blank" rel="noopener">leetcode 官方解答</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;h3 id=&quot;329-矩阵中的最长递增路径&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#329-矩阵中的最
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【每日一题Day 1】 分割数组的最大值</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/</id>
    <published>2020-07-25T12:35:20.000Z</published>
    <updated>2020-07-25T12:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="410-分割数组的最大值"><a class="markdownIt-Anchor" href="#410-分割数组的最大值"></a> <a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 _m _个非空的连续子数组。设计一个算法使得这 _m _个子数组各自和的最大值最小。</p><p><strong>注意:</strong><br />数组长度 _n _满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><h1 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答"></a> 题目解答</h1><h2 id="方法一-动态规划"><a class="markdownIt-Anchor" href="#方法一-动态规划"></a> 方法一： 动态规划</h2><h3 id="分析过程"><a class="markdownIt-Anchor" href="#分析过程"></a> 分析过程</h3><h4 id="错误的状态转移方程"><a class="markdownIt-Anchor" href="#错误的状态转移方程"></a> 错误的状态转移方程</h4><p>实不相瞒，我第一眼看到该题时，思考的方法为：</p><p>创建 m 个空数组，每次将新数字添加到当前数字之和最小的空数组中。很明显这种方法是不正确的。（脑瘫行为😂）</p><h4 id="正确的状态转移方程"><a class="markdownIt-Anchor" href="#正确的状态转移方程"></a> 正确的状态转移方程</h4><p>题目中提到两个变量，连续子数组个数 m，数组内数字个数n。 我们假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示将前 i 个数字按照要求分为 j 份所能得到的最大连续和的最小值，考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，枚举 k 属于 1~j，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 可以视为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[k][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_k^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span> 中较大者，详细描述如图：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC.jpg" alt="分割数组最大值" /></p><p>根据动态转移方程编写对应代码：</p><p>值得注意的是，除了考虑 i &lt; j 的情况，还要注意i 、j 为 0 的初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">// 需要预留(0,0) 的空间，否则会因为初始的 MAX_VALUE 导致结果出错</span></span><br><span class="line">        <span class="keyword">int</span>[][] results = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=length;i++) &#123;</span><br><span class="line">            Arrays.fill(results[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免结果被MAX_VALUE</span></span><br><span class="line">        results[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化前n项和,用于快速计算连续序列的和</span></span><br><span class="line">        <span class="keyword">int</span>[] preArrayResult = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            preArrayResult[i+<span class="number">1</span>] = preArrayResult[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过三层循环 得到f[i][j] 的所有结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i, m); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    <span class="comment">// 根据递推公式转换而来</span></span><br><span class="line">                    results[i][j] = Math.min(results[i][j], Math.max(results[k][j - <span class="number">1</span>], preArrayResult[i] - preArrayResult[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面的循环同理</span></span><br><span class="line">        <span class="comment">// for(int j = 1;j&lt;=m;j++) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int i=0;i&lt;=length; i++)&#123;</span></span><br><span class="line">        <span class="comment">//         for (int k = 0; k &lt; i; k++) &#123;</span></span><br><span class="line">        <span class="comment">//             results[i][j] = Math.min(results[i][j], Math.max(results[k][j - 1], preArrayResult[i] - preArrayResult[k]));</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> results[length][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="方法二-二分查找-贪心"><a class="markdownIt-Anchor" href="#方法二-二分查找-贪心"></a> 方法二： 二分查找 + 贪心</h2><p>原理很简单，很明显我们的答案在一个可以预测的范围内：其下界大于所有数字中最大的数。其上界小于所有数字的和。即：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\in(max(a),\sum(a))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>对于排序的数组内寻找符合条件的值，自然使用二分法，配合贪心算法判断是否存在分割方法满足要求即可。</p><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><p><font color=#C71585><strong>这其实是我个人的问题，因为不常写二分查找算法的缘故，这题我加了很多判断条件才算解决</strong></font></p><ul><li>本题可以取下界却不能取上界（下界可能为问题的解）</li><li>修改边界时，对于可取边界要 +1 ： left = mid + 1;</li><li>为了避免整数溢出，最好使用 (right - left) / 2 + left 计算 mid  （我将 mid 设为了 double 类型）</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>不难判断本题的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(sum - maxn))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>类似穷举法的题目还有很多，比如一定范围内质数、符合某项规定的数字等等。可以考虑该解法减少运算量。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/1595702409237.jpeg" alt="img" /></p>]]></content>
    
    <summary type="html">
    
      动态规划、二分查找、贪心相关
    
    </summary>
    
    
      <category term="编程算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二分查找" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="贪心算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第一年工作总结</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/25/%E7%AC%AC%E4%B8%80%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/25/%E7%AC%AC%E4%B8%80%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-25T08:10:18.000Z</published>
    <updated>2020-07-25T08:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总述"><a class="markdownIt-Anchor" href="#总述"></a> 总述</h1><p>不知不觉，已经离开校园一年了，短短一年换了两家公司，惭愧啊 😂。有时候我也怀疑俺的路咋就越走越窄了呢？</p><p>写下这篇文章，假如我的经历可以为您起到一点参照的作用，我就非常开心乐😊</p><h2 id="在tp-link-的五个月"><a class="markdownIt-Anchor" href="#在tp-link-的五个月"></a> 在TP-link 的五个月</h2><p>很幸运校招的时候参加了普联的招聘会，整个招聘过程挺顺利的，没遇到啥问题就拿到了offer。（本来说考研呢，但是自己羊儿愣子，嘿嘿差的比较多，但是学了政治感觉扩宽了视野），之后便是继续在宿舍浪了😁。</p><h3 id="入职培训"><a class="markdownIt-Anchor" href="#入职培训"></a> 入职培训</h3><p>七月十七号，正式到公司报到。进入公司的第一个星期，公司对新员工进行了入职培训（大家一起做游戏啦）；以八个人为单位组成小组进行互动游戏，我有幸分到了“黄金圣斗士组”，同组的硕士生超过了一半，还认识了一位清华的老乡😀，大家玩的都很开心。其中有个名为“国际贸易”的游戏给我留下了很深的印象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">规则：</span><br><span class="line">每组将会扮演一个国家，每个国家&#39;地貌&#39;不同，持有的资源也有差别。</span><br><span class="line">资源包括：纸张、剪刀、尺子、铅笔、宝箱。</span><br><span class="line">&#39;国家&#39;可以使用手中的资源生产：正三角形、直角三角形、半圆、方形卡片</span><br><span class="line">组织者扮演贸易出的角色，&#39;国家&#39;可以将生产的产品到贸易处进行销售，不同产品对应不同价格，且价格会进行波动</span><br><span class="line">每个&#39;国家&#39;拥有一个销售员与交易员，销售员可以将产品带到贸易处销售，交易员可以与他国交换资源。</span><br><span class="line">每过一段时间，贸易处将会拍卖一些资源(价高者得)</span><br><span class="line">游戏过程中可以贷款，偿还10%的利润</span><br><span class="line">裁剪不合格的产品不能得到报酬，规定时间内获得金钱最多的‘国家’获胜</span><br></pre></td></tr></table></figure><p>事实上仅有一组手里有完善的道具进行生产，但该组手里的纸张非常少。拥有宝箱的组资源最为匮乏。我们组手里纸张最多，但是别的资源几乎没有😂</p><p>在组长的带领下，我们使用直尺代替剪刀裁剪纸张，使用指甲痕代替铅笔绘制裁剪线，生产了一些不合格的产品😂。正一筹莫展之际，隔壁最穷组找到我们，他们愿意把生产的物资的一半加一个宝箱给我们，条件是把我们手里的资源都给他。我们财大气粗的组长同意了，全组人都成了甩手掌柜，当上了资本家😀。</p><p>宝箱是简单的三位数字密码锁，经过简单的尝试后，我们打开了空宝箱😂。</p><p>临近结束时，隔壁组给我们送来了几个三角形，他们说其他的因为裁剪不合格报废了。</p><p>最终隔壁组拿到了第一名，原来宝箱里的奖励是“所有正方形价格翻倍”，隔壁组凭借着‘租借’的资源以及宝箱奖励成为了最富的人😀</p><p>当然，我们组也不是最后一名，因为有个组为了购买拍卖的纸张破产了🤔（文笔不好，见谅）</p><h3 id="入职"><a class="markdownIt-Anchor" href="#入职"></a> 入职</h3><p>很快到了入职的日子，我有幸分到了ios开发组，结识了益智兄，还遇到了聪哥、我的导师曾哥。不过有个很尴尬的事情是：我一直都不知道进入公司后会做ios开发😂，也就是说在公司的发展方向与我自己希望的发展方向存在出入。</p><p>四个月的实习期很快，也很顺利的过去了，在这期间，我摸到了ios开发的门槛，基本掌握了简单ios应用、游戏的开发。（仅限使用swift语言，Object-C确实难搞啊😂）</p><h3 id="离职"><a class="markdownIt-Anchor" href="#离职"></a> 离职</h3><p>为什么五个月就从普联离职？ 我认为原因有三个：</p><ul><li>个人比较偏向后端等与界面交互不紧密的开发方向</li><li>知乎上一些关于公司不成熟的言论影响了我的判断</li><li>个人心里没B数😂，加上知乎鼓吹年轻人尝试😭</li></ul><p>在Boss直聘上挂上自己的简历后，找到了一份华为松山湖的岗位。Hr跟我说岗位是“linux应用开发”，还跟AI相关呢</p><p>记得离职时，我的直接领导（比我大五六岁）提醒我，我对取华为到底做什么其实一无所知，其次，可以考虑在公司内转岗。额，我觉得麻烦同事不太好，俺还是自己闯闯吧😀</p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>确实是太年轻了，说实话普联作为一个 865的公司，薪资也高，这么随意就丢掉了这份工作，也就我这样的脑残做的出来了😂。千万不要被知乎迷惑啊。。。。</p><h2 id="在华为的五个月"><a class="markdownIt-Anchor" href="#在华为的五个月"></a> 在华为的五个月</h2><p>华为因为招聘策略改变的缘故，当年九月之后所有社招员工均以od的形式发放offer，我也成为了其中的一员。</p><h3 id="入职-2"><a class="markdownIt-Anchor" href="#入职-2"></a> 入职</h3><p>记得我入职时，我的导师翔宇哥提前一天帮我把办公用具带到了工位，团队的pl也对我非常照顾。华为给我的感觉是团队之间的联系很紧密。小团队内经常一起去食堂吃饭、散步、回家。在普联时，我基本是跟益智一起去吃饭，在这边就是好多人一起去吃饭了。我想这也是华为能加班这么晚的原因：在公司跟在家一样，所以也没有早回家的需求了。</p><p>不过我很快发现了一个问题：团队内只有两个开发😂(算上我)。</p><p>开发的产品使用的技术很老旧，并没有用到什么框架，不过还好是Java开发</p><p>之后的几个月，团队逐渐招了更多开发进来，很多经验丰富的开发人员加入了我们的项目。pl也搞了个新员工知识分享，大家在吃过晚饭后，分享一些工作中涉及到的有用的小技巧。（其实主要是东伟哥、黄杰哥分析他们的经验给我们😀）</p><p>东伟哥对我们的项目架构进行了调整，使用了CQRS 消息队列等技术，项目瞬间高大上起来(<em><sup>_</sup></em>)</p><h3 id="离职-2"><a class="markdownIt-Anchor" href="#离职-2"></a> 离职</h3><p>额，这次离职的原因嘛，我个人认为一是薪资低了不少；二是职位挂在od下，没有前途可言；三是我想回长江三角洲🤩</p><h3 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h3><p>离职这种事情，还是慎重的好。随随便便离职真的顶不住啊😂 。</p><p>华为内部很注重编码能力，所有员工都要在leetCode刷题，也是在华为的经历，我认识到了刷题的重要性。</p><p>其次，知识的积累也很重要，也正是处于这个原因，我搭建了自己的博客</p><h1 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h1><p>发现自己的写作水平以及无限趋近于零了 😭 ，好好努力把 小伙子</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E5%B8%83%E5%91%97%E5%87%BB%E5%9E%AE.jpg" alt="img" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#总述&quot;&gt;&lt;/a&gt; 总述&lt;/h1&gt;
&lt;p&gt;不知不觉，已经离开校园一年了，短短一年换了两家公司，惭愧啊 😂。有时候我也怀疑俺的路咋就越走越窄了呢？&lt;/p&gt;
&lt;p&gt;写下这篇文章，假如我的经
      
    
    </summary>
    
    
      <category term="个人感悟" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="人生感想" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%83%B3/"/>
    
      <category term="职业规划" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
