<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小的毛毛虫</title>
  <icon>https://www.gravatar.com/avatar/d1ef88200293f35641bebedc91aa7821</icon>
  <subtitle>小小的毛毛虫，也想要破茧成蝶</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/"/>
  <updated>2020-07-29T04:58:40.000Z</updated>
  <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/</id>
  
  <author>
    <name>gaoxiang</name>
    <email>630268696@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作第一年总结</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/29/%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/29/%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-29T04:58:40.000Z</published>
    <updated>2020-07-29T04:58:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【树、图】深度广度算法全解析</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/28/%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E7%AE%97%E6%B3%95%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/28/%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E7%AE%97%E6%B3%95%E5%85%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2020-07-28T08:42:11.000Z</published>
    <updated>2020-07-28T08:42:11.000Z</updated>
    
    <summary type="html">
    
      主要介绍图相关解法
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一只名叫孟德的鸡</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/28/%E4%B8%80%E5%8F%AA%E5%90%8D%E5%8F%AB%E5%AD%9F%E5%BE%B7%E7%9A%84%E9%B8%A1/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/28/%E4%B8%80%E5%8F%AA%E5%90%8D%E5%8F%AB%E5%AD%9F%E5%BE%B7%E7%9A%84%E9%B8%A1/</id>
    <published>2020-07-28T08:42:11.000Z</published>
    <updated>2020-07-28T08:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一只名叫孟德的鸡"><a class="markdownIt-Anchor" href="#一只名叫孟德的鸡"></a> 一只名叫孟德的鸡</h1><p>这篇文章是我在华为工作时，作者发布到心声社区的，那时作者离职了，走前留下了一篇文章。写的确实不错，摘录在这里，有兴趣的话可以读一读。</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">我现在生活在一座有着几百万人口的村子里。天空永远是灰蒙蒙的，仿佛患有咽炎的天公，随口所吐了一坨老痰，笼罩在如蚁众生的头顶。村里到处是工地，渣土车像黄色的怪兽，从四处出发，又目空一切地分赴四方，身后尘土飞扬、黑烟滚滚，留下一团团经年不散的雾霾。在这里只有黑夜和白天的区别，很难看出晴天和阴天有什么不同。村道两旁的树木风尘仆仆，仿佛刚刚经过泥浴，每一片树叶，每一根树枝，都像是用泥浆浇铸而成。柏油马路早已失去了昔日黝黑的本色，此时更像是洪水漫过的旧河床，上面淤积凝结了一层厚厚的泥沙。村民们将生活垃圾堆积在路口，散发着腐烂水果和发霉饭菜所特有的怪味，随着各色的塑料袋四散漫延。如若有幸遇到大雨，你便会看到一江洪水从眼前浩浩流过，隐约间还泛发着一阵阵或浓或淡的泔水味，此时便难免悲哀，原来我生活在一桶泔水中啊！</span><br><span class="line">   </span><br><span class="line">   我年少时也住在村里。除去农忙季节和过年的时候，村里的男人大多外出，在本地或外省的工地上打工，那时他们还没有农民工的称谓， 也没有进城务工人员这样尊严体面的头衔。妇女们多半留守在家----种地、伺领孩子，当然，若是在主旋律作家的笔下，还会加上一条：奉养公婆。之所以说大多男人和妇女如此，是因为还有个别壮年男人常年在家，搓搓麻将，打打纸牌，醉后到寡妇门口耍耍酒疯，万不得已时也会去田里劳作一番，同时，也有少量妇女外出务工，以补贴家用。我想，如若仅从社会分工的角度来区分男女，那一定是上帝跟他们开了个玩笑。</span><br><span class="line"></span><br><span class="line">   村民们除了种地和外出打工外，也会在家饲养一些禽畜，如牛驴、猪羊、鸡鸭等，不一而足。这些禽畜的命运是悲哀的，从它们一出生便注定了要度过悲惨的一生。生活在拥挤、潮湿、臭气熏天的恶劣环境中，吃着其它物种淘汰下来的残渣，却要忍受毕生的劳役，或坐等被宰杀的日子一天天逼近。仅以鸡为例，母鸡的工作主题便是日复一日地下蛋，公鸡则只能坐待某日被献上祭台，或端上餐桌，终其一生，没有任何其它希望。没有一种悲哀更能令自己沮丧、惶恐了，那便是忍看被注定的命运向自己逼近却又无力更改，而这命运又是如此悲惨！</span><br><span class="line"></span><br><span class="line">   但，回首看看村民们的命运，也并不比鸡鸭好到哪里去。那些在工地上打工的人们，日复一日干着繁重的体力活，从未体验过八小时工作制，以及周末双休为何物。岁月的风霜在他们脸上留下了显而易见的痕迹，犹如经过刀劈斧砍的松木。那黝黑木然的脸庞布满了皱纹，像是纵横的沟壑，壅塞着积年的粉尘与污泥。盛夏季节，很多人每天都要喝下去两大桶凉水，以解渴消暑。那用以饮水的桶，则是刚刚刷完油漆留下的，桶壁上依然凝结着残余的漆块，水面上泛着一层薄薄的松脂色油腻，凑上前去，还会闻到一缕刺激眼鼻的气味。好在他们并不知道它的危害，从而减少了一份徒劳无功的愤怒，和惨白无力的忧虑。这对他们而言，未尝不是一件好事，许多事情，既然知道了也是无可奈何，又何苦徒增烦恼。这世界上再耀眼炙热的光芒，也照不到他们所处的黑暗阴冷的角落。世上最易压迫与剥削的无外乎这种沉默无知的奴隶，他们一如千百年来的祖辈，唯唯懦懦、苟且偷生，一代又一代重复着千百年来被注定的命运，却无任何去试图更改的尝试。眼见着可以预见的未来，一天天变成惨淡的现实，就如同忍看死神一步步向自己逼近，而又呆若木鸡、无动于衷。他们看似活着，其实早已死亡，从那开始安于可以预见的未来的一刻起，便已静候于墓地，等待死神的光临。</span><br><span class="line"></span><br><span class="line">   那时候我家后院也养有十几只鸡，有三五只是公鸡，其余均是母鸡。按照往年的惯例，所有的公鸡都会在当年年底被宰杀，除却用以祭祀灶神外，还要招待春节期间往来的亲友。但也有例外，有一年鸡群当中就有一只鸡，是从前一年遗留下来的。小年那天，当另外几只鸡束手就擒时，它从鸡圈的破损处逃离了出去，从而摆脱了和其它公鸡同样的命运。我当时还在读中学，课本中有一篇《赤壁之战》，曹操败后狼狈而逃，其仓惶状与此鸡颇为神似，我便不顾亵渎先贤的忌讳，称这只鸡为孟德。后来读了《三国演义》，看到曹操和我家孟德机敏无二，这个称呼更是让我倍感贴切。当然，华容道后来被家兄给堵上了，我当时又开始担心，下次孟德该如何逃脱。</span><br><span class="line"></span><br><span class="line">   也许是因为年长一岁的缘故，孟德的鸡冠已不复火焰般鲜红，像一抹淡淡的血液凝结在上面而呈现绛紫色，仔细看去，就会发现有细小的暗紫色血痂星列其上，那是和其它公鸡争斗时留下的。曾经灵动机警的双眼日渐变得清澈凌冽，偶泛寒光之余更多的是淡然。身上的羽毛已不再有朝霞般绚烂夺目的光焰，更像夕阳西下后徘徊于天边的暮云，厚重的质感镀上了金边，又如反射着阳光的紫铜，闪耀着沉着的光泽。每当有阳光倾泻于栏中，众鸡拥挤在一角，懒洋洋地爬卧着，孟德便在墙脚的阳光下散步。只见它尾羽微翘，双翅紧收，颈项稍稍前倾，支撑着昂扬的头颅。鸡爪轻轻收起，略作悬停，随后往前迅疾一探，继而稳稳地踩下去，反复如是，在四五米长的墙脚下来回踱步。其神其态，仿佛一位微熏的伟岸老者，拥着丰腴高挑的中年女伴，在音乐中悠然起舞。老人红光满面、皓发似雪，女伴雍容蔼蔼、风韵翩翩，入目之中，不仅是赏心悦目的艺术美感，更是浸透了岁月沧桑的优雅与恬淡。我想，与其说是岁月给孟德带来了这种风姿，不若说是岁月中的风霜与经历，给了它一颗平和宁静的心。</span><br><span class="line"></span><br><span class="line">   那年秋日的某一下午，晴光四溢，天风浩荡，如丝如缕的白云在万里碧空缓缓漂移，如新生的杨絮浮游于无际的水面。也许西北的风中总是裹挟着细微的尘沙，天空并非清澈透明的蓝，像是用河畔纯净的细沙轻轻打磨了一遍，隐隐泛着一抹淡淡的银辉，增添了几分婉约的迷蒙。鸡群从栏中放出，在院北的墙脚下，或觅食，或懒散地晒着阳光。几只公鸡不安分地跳上一辆倚墙而立的自行车，静静地闭目养神，享受着难得的自由，孟德也在其中。出于一种无聊，我突然向鸡群猛地一冲，恶作剧地大吼一声，群鸡大惊，鼠窜而散。与此同时，忽见一只鸡从自行车上腾空而起，扑扇着翅膀奋力飞上墙沿，挣扎了一番，终于稳稳地站在墙头。面朝阳光，扬首而立，为之四顾，为之踌躇满志，原来是孟德。</span><br><span class="line"></span><br><span class="line">   我想，它一定在腾起的一瞬，感受到了风的速度，它一定在墙头，看到了更广阔的大地，和更高远的天空。在那一刻，我看到它的翅尖闪烁着自由的光辉，仿佛有万千只金色的喇叭齐声长鸣，有万千束金色的阳光穿透长空，那是为它奏响的华章，为它绽放的火焰。我看到，不甘的魂灵，闪耀着生命尊严的荣光。</span><br><span class="line"></span><br><span class="line">   此后，孟德便自由了。每逢天气晴朗、风光和畅的日子，它便会从鸡栏中跃出，到宽广的天地中享受独属于它的自由。我也不再为它的命运担心，那些困住庸众的围栏，已不再是它生命中的樊篱。每次家中来亲友时，孟德都会主动跑到院后的田野中去，直到亲友离开才会回来。有时我会担忧，怕它在外面吃不饱，便时常从粮仓中拿出上好的小麦喂它，任栏中的鸡群焦躁地鸣叫而置之不理。待孟德吃完，我再拿出剩饭或麸糠给其它鸡群进食，它们既然无可奈何，不久便也安之若素了。有时候过了饭点，仍未见孟德回来，我知道，它一定是在田间地头吃饱了，那里有新鲜的菜叶和爬虫，以及甘怡的晨露。</span><br><span class="line"></span><br><span class="line">   小年又到了。尽管此前家人多次提到一定要拿孟德祭灶，但我丝毫不为它担忧，那些在群鸡眼中不可逾越的障碍，在孟德面前不过是用以表演的道具罢了，它的观众有我，还有同类的鸡群。果然，小年那日清早，当家兄蹑手蹑脚走向鸡栏，甫一靠近，孟德便从栏中跳出，一溜烟逃到院后的田野中去了。是时天气寒冷，浇过冬水的田地中早已结冰，加之家兄身形肥拙，只能任孟德逍遥而去，拿另外一只鸡替代。这只鸡经年安卧于栏中，如此的命运该是它早已预料到的，然而只有这种预料中的悲惨成为难以更改的现实时，才会有痛彻心扉的悔恨，却也悔之晚矣。</span><br><span class="line"></span><br><span class="line">   那年冬天太冷了，滴水结冰，呵气凝霜。</span><br><span class="line"></span><br><span class="line">   次日早晨，当躲在草垛中的孟德被发现时，它已经冻僵了。这一次，它未能幸免。当鲜血涌出的一瞬，它突然奋力一蹬，腾然而起，扇动着翅膀跳跃起两米多高，院中风尘为之激荡，血雨洒满了墙壁和地面。它反复地跌落，又反复地跳起，如是十余次，一切方重归寂静。</span><br><span class="line"></span><br><span class="line">   孟德离去好多年了。这期间，我看到有无数人，年复一年地重复着寡淡无奇的生活，任由明日变为今日，再变为昨日，任由昨日成为今日，再成为明日。他们尚未留下记忆，就已被遗忘。倒是那只鸡腾空跃起、振翅欲飞的影子，时常在我脑海中浮现，难免让人怀念。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在华为心声社区看到的文章
    
    </summary>
    
    
      <category term="精彩短文" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%B2%BE%E5%BD%A9%E7%9F%AD%E6%96%87/"/>
    
    
      <category term="小说" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="人生" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题Day 4】 从 二叉树最大深度 学习编程小技巧</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day4/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day4/</id>
    <published>2020-07-28T05:26:03.000Z</published>
    <updated>2020-07-28T05:26:03.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【每日一题Day3】</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/27/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day3%E3%80%91/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/27/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day3%E3%80%91/</id>
    <published>2020-07-27T14:53:15.000Z</published>
    <updated>2020-07-27T14:53:15.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【每日一题Day3】逆向思维——逃离大迷宫</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/</id>
    <published>2020-07-27T14:53:15.000Z</published>
    <updated>2020-07-27T14:53:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p><font color=#FF1493 font = 10><strong>虽然没有做多少题呢，但是我已经发现了，做题，怕的不是没有思路，而是不敢尝试。</strong></font></p><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="1036-逃离大迷宫"><a class="markdownIt-Anchor" href="#1036-逃离大迷宫"></a> <a href="https://leetcode-cn.com/problems/escape-a-large-maze/" target="_blank" rel="noopener">1036. 逃离大迷宫</a></h3><p>Difficulty: <strong>困难</strong></p><p>在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 <code>(x, y)</code>，其中 <code>0 &lt;= x, y &lt; 10^6</code>。</p><p>我们从源方格 <code>source</code> 开始出发，意图赶往目标方格 <code>target</code>。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 <code>blocked</code> 上。</p><p>只有在可以通过一系列的移动到达目标方格时才返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [[0,1],[1,0]], source &#x3D; [0,0], target &#x3D; [0,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">从源方格无法到达目标方格，因为我们无法在网格中移动。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [], source &#x3D; [0,0], target &#x3D; [999999,999999]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">因为没有方格被封锁，所以一定可以到达目标方格。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= blocked.length &lt;= 200</code></li><li><code>blocked[i].length == 2</code></li><li><code>0 &lt;= blocked[i][j] &lt; 10^6</code></li><li><code>source.length == target.length == 2</code></li><li><code>0 &lt;= source[i][j], target[i][j] &lt; 10^6</code></li><li><code>source != target</code></li></ol><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析：</h2><p>本题可以抽象为，能不能通过 blocked 将网格分成互不连通的两部分，且起点与原点分别位于分割线的两侧。进一步观察所给的参数：</p><ul><li>网格大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，基本可以放弃对网格做什么操作了。</li><li>blocked.length 的范围为 [0,200] ，完全在一个可接受的范围内，可以尝试从此入手</li></ul><h2 id="方法一寻找链接原点与终点的路径"><a class="markdownIt-Anchor" href="#方法一寻找链接原点与终点的路径"></a> 方法一：寻找链接原点与终点的路径</h2><p>老实说，该方法我还没看懂，在此贴出对应的链接地址，有兴趣可以试试这种方法😂</p><a class="btn-beautify button--animated pink right outline larger" href="https://leetcode-cn.com/problems/escape-a-large-maze/solution/cong-zhang-ai-wu-dian-blockedru-shou-de-kuai-su-su/"   title="从障碍物点入手的快速算法"><i class="far fa-hand-point-right fa-fw"></i><span>从障碍物点入手的快速算法</span></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面的话&quot;&gt;&lt;/a&gt; 写在前面的话&lt;/h1&gt;
&lt;p&gt;&lt;font color=#FF1493 font = 10&gt;&lt;strong&gt;虽然没有做多少题呢，但是我已经发现了，做题，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【每日一题Day 2】 矩阵中的最长递增路径</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/</id>
    <published>2020-07-26T08:07:53.000Z</published>
    <updated>2020-07-26T08:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="329-矩阵中的最长递增路径"><a class="markdownIt-Anchor" href="#329-矩阵中的最长递增路径"></a> <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><h2 id="方法一-记忆化深度优先搜索"><a class="markdownIt-Anchor" href="#方法一-记忆化深度优先搜索"></a> 方法一： 记忆化深度优先搜索</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><p>对于本题很容易找到解题思路：</p><ul><li>找到每个位置可以到达的下个位置（构造了树结构）</li><li>找到构造的树结构所能到达的最大深度</li></ul><p>我们的树结构看起来不那么好构造，但实际上我们需要获得的是树的深度，因此：</p><ul><li>创建额外的空间存储以当前数字为根节点构造的树所能达到的最大深度</li><li>列出动态转移方程： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo>∑</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>a</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(\sum(0, around))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>around 指矩阵的四周</li></ul><p>根据思路编写实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组模拟遍历操作(也可以模拟九宫格，应该可以😂)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] besideList = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 与其在函数外部对 0、null判断，不如交给函数内部判断。 切记切记</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> sizeX = matrix.length;</span><br><span class="line">       <span class="keyword">int</span> sizeY = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] resultDeep = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;sizeX;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sizeY;j++)&#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,i,j,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxDeep;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] resultDeep)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(resultDeep[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;besideList.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> nowX = x + besideList[i];</span><br><span class="line">           <span class="keyword">int</span> nowY = y + besideList[i+<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(!isInArray(nowX,nowY,matrix))&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(matrix[x][y]&lt;matrix[nowX][nowY]) &#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,nowX,nowY,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       resultDeep[x][y] = maxDeep + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 如果返回 boolean ，最好return &#123;逻辑语句&#125; , 而不是通过 if else 返回 true 或 false</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;matrix.length&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><ul><li>时间复杂度分析： O(mn),其中 m 和 n 分别是矩阵的行数和列数。深度优先搜索的时间复杂度是 O(V+E)，其中 V 是节点数，E 是边数。在矩阵中，O(V)=O(mn)。</li><li>空间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。空间复杂度主要取决于缓存和递归调用深度，缓存的空间复杂度是 O(mn)，递归调用深度不会超过 mn。</li></ul><h3 id="遗留问题"><a class="markdownIt-Anchor" href="#遗留问题"></a> 遗留问题</h3><p><font color=#FF4500><strong> 对深度优先算法、广度优先算法没有做到掌握，将在之后的篇章给出进一步总结。</strong></font></p><h2 id="方法二拓扑排序动态规划"><a class="markdownIt-Anchor" href="#方法二拓扑排序动态规划"></a> 方法二：拓扑排序（动态规划）</h2><h2 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h2><p>类比寻找二叉树深度的算法，其本质上是 DFS 的循环实现，本题的难点在于如何找到循环的依据：</p><ul><li><p>将数组看作有向图，寻找出度为0的点（即最大点）</p></li><li><p>从所有出度为0的点进行广度优先搜索，并更新出度值，将新的出度为0的点加入搜索队列内</p></li><li><p>搜索总层数即为矩阵中最长递增路径的长度</p><p><font color=#C71585><strong>懒了没有编写对应的实现代码，直接贴了题解</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 太长了不想贴，回头自己写个再补上吧</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析：</h3><p>与方法一相同，但是实现上复杂了许多</p><h3 id="遗留问题-2"><a class="markdownIt-Anchor" href="#遗留问题-2"></a> 遗留问题：</h3><ul><li><p>「方法一」中使用了记忆化存储和深度优先搜索，这里的深度优先搜索可以替换成广度优先搜索吗？</p></li><li><p>「方法二」中基于拓扑排序对排序后的有向无环图做了层次遍历，如果没有拓扑排序直接进行广度优先搜索会发生什么？</p></li><li><p>「方法二」中如果不使用拓扑排序，而是直接按照矩阵中元素的值从大到小进行排序，并依此顺序进行状态转移，那么可以得到正确的答案吗？如果是从小到大进行排序呢？</p></li><li><p>「变式」给定一个整数矩阵，找出符合以下条件的路径的数量：该路径严格递增，切长度至少为3.矩阵边长最大为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，答案对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 取模。其他条件与题目相同。思考对应解法</p></li></ul><h4 id="答案见如下文章"><a class="markdownIt-Anchor" href="#答案见如下文章"></a> 答案见如下文章：</h4><h4 id="文章部分思路借鉴"><a class="markdownIt-Anchor" href="#文章部分思路借鉴"></a> 文章部分思路借鉴：</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/" target="_blank" rel="noopener">leetcode 官方解答</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;h3 id=&quot;329-矩阵中的最长递增路径&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#329-矩阵中的最
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【每日一题Day 1】 分割数组的最大值</title>
    <link href="https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/"/>
    <id>https://github.com/gaoxiang15125/gaoxiang15125.github.io/2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/</id>
    <published>2020-07-25T12:35:20.000Z</published>
    <updated>2020-07-25T12:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="410-分割数组的最大值"><a class="markdownIt-Anchor" href="#410-分割数组的最大值"></a> <a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 _m _个非空的连续子数组。设计一个算法使得这 _m _个子数组各自和的最大值最小。</p><p><strong>注意:</strong><br />数组长度 _n _满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><h1 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答"></a> 题目解答</h1><h2 id="方法一-动态规划"><a class="markdownIt-Anchor" href="#方法一-动态规划"></a> 方法一： 动态规划</h2><h3 id="分析过程"><a class="markdownIt-Anchor" href="#分析过程"></a> 分析过程</h3><h4 id="错误的状态转移方程"><a class="markdownIt-Anchor" href="#错误的状态转移方程"></a> 错误的状态转移方程</h4><p>实不相瞒，我第一眼看到该题时，思考的方法为：</p><p>创建 m 个空数组，每次将新数字添加到当前数字之和最小的空数组中。很明显这种方法是不正确的。（脑瘫行为😂）</p><h4 id="正确的状态转移方程"><a class="markdownIt-Anchor" href="#正确的状态转移方程"></a> 正确的状态转移方程</h4><p>题目中提到两个变量，连续子数组个数 m，数组内数字个数n。 我们假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示将前 i 个数字按照要求分为 j 份所能得到的最大连续和的最小值，考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，枚举 k 属于 1~j，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 可以视为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[k][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_k^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span> 中较大者，详细描述如图：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC.jpg" alt="分割数组最大值" /></p><p>根据动态转移方程编写对应代码：</p><p>值得注意的是，除了考虑 i &lt; j 的情况，还要注意i 、j 为 0 的初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">// 需要预留(0,0) 的空间，否则会因为初始的 MAX_VALUE 导致结果出错</span></span><br><span class="line">        <span class="keyword">int</span>[][] results = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=length;i++) &#123;</span><br><span class="line">            Arrays.fill(results[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免结果被MAX_VALUE</span></span><br><span class="line">        results[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化前n项和,用于快速计算连续序列的和</span></span><br><span class="line">        <span class="keyword">int</span>[] preArrayResult = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            preArrayResult[i+<span class="number">1</span>] = preArrayResult[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过三层循环 得到f[i][j] 的所有结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i, m); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    <span class="comment">// 根据递推公式转换而来</span></span><br><span class="line">                    results[i][j] = Math.min(results[i][j], Math.max(results[k][j - <span class="number">1</span>], preArrayResult[i] - preArrayResult[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面的循环同理</span></span><br><span class="line">        <span class="comment">// for(int j = 1;j&lt;=m;j++) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int i=0;i&lt;=length; i++)&#123;</span></span><br><span class="line">        <span class="comment">//         for (int k = 0; k &lt; i; k++) &#123;</span></span><br><span class="line">        <span class="comment">//             results[i][j] = Math.min(results[i][j], Math.max(results[k][j - 1], preArrayResult[i] - preArrayResult[k]));</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> results[length][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="方法二-二分查找-贪心"><a class="markdownIt-Anchor" href="#方法二-二分查找-贪心"></a> 方法二： 二分查找 + 贪心</h2><p>原理很简单，很明显我们的答案在一个可以预测的范围内：其下界大于所有数字中最大的数。其上界小于所有数字的和。即：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\in(max(a),\sum(a))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>对于排序的数组内寻找符合条件的值，自然使用二分法，配合贪心算法判断是否存在分割方法满足要求即可。</p><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><p><font color=#C71585><strong>这其实是我个人的问题，因为不常写二分查找算法的缘故，这题我加了很多判断条件才算解决</strong></font></p><ul><li>本题可以取下界却不能取上界（下界可能为问题的解）</li><li>修改边界时，对于可取边界要 +1 ： left = mid + 1;</li><li>为了避免整数溢出，最好使用 (right - left) / 2 + left 计算 mid  （我将 mid 设为了 double 类型）</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>不难判断本题的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(sum - maxn))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>类似穷举法的题目还有很多，比如一定范围内质数、符合某项规定的数字等等。可以考虑该解法减少运算量。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/1595702409237.jpeg" alt="img" /></p>]]></content>
    
    <summary type="html">
    
      动态规划、二分查找、贪心相关
    
    </summary>
    
    
      <category term="编程算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二分查找" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="贪心算法" scheme="https://github.com/gaoxiang15125/gaoxiang15125.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
