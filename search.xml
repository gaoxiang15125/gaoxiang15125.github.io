<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>工作第一年总结</title>
      <link href="/2020/07/29/%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/29/%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="总述"><a class="markdownIt-Anchor" href="#总述"></a> 总述</h1><p>不知不觉，已经离开校园一年了，短短一年换了两家公司，惭愧啊 😂。有时候我也怀疑俺的路咋就越走越窄了呢？</p><p>写下这篇文章，假如我的经历可以为您起到一点参照的作用，我就非常开心乐😊</p><h2 id="在tp-link-的五个月"><a class="markdownIt-Anchor" href="#在tp-link-的五个月"></a> 在TP-link 的五个月</h2><p>很幸运校招的时候参加了普联的招聘会，整个招聘过程挺顺利的，没遇到啥问题就拿到了offer。（本来说考研呢，但是自己羊儿愣子，嘿嘿差的比较多，但是学了政治感觉扩宽了视野），之后便是继续在宿舍浪了😁。</p><h3 id="入职培训"><a class="markdownIt-Anchor" href="#入职培训"></a> 入职培训</h3><p>七月十七号，正式到公司报到。进入公司的第一个星期，公司对新员工进行了入职培训（大家一起做游戏啦）；以八个人为单位组成小组进行互动游戏，我有幸分到了“黄金圣斗士组”，同组的硕士生超过了一半，还认识了一位清华的老乡😀，大家玩的都很开心。其中有个名为“国际贸易”的游戏给我留下了很深的印象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">规则：</span><br><span class="line">每组将会扮演一个国家，每个国家&#39;地貌&#39;不同，持有的资源也有差别。</span><br><span class="line">资源包括：纸张、剪刀、尺子、铅笔、宝箱。</span><br><span class="line">&#39;国家&#39;可以使用手中的资源生产：正三角形、直角三角形、半圆、方形卡片</span><br><span class="line">组织者扮演贸易出的角色，&#39;国家&#39;可以将生产的产品到贸易处进行销售，不同产品对应不同价格，且价格会进行波动</span><br><span class="line">每个&#39;国家&#39;拥有一个销售员与交易员，销售员可以将产品带到贸易处销售，交易员可以与他国交换资源。</span><br><span class="line">每过一段时间，贸易处将会拍卖一些资源(价高者得)</span><br><span class="line">游戏过程中可以贷款，偿还10%的利润</span><br><span class="line">裁剪不合格的产品不能得到报酬，规定时间内获得金钱最多的‘国家’获胜</span><br></pre></td></tr></table></figure><p>事实上仅有一组手里有完善的道具进行生产，但该组手里的纸张非常少。拥有宝箱的组资源最为匮乏。我们组手里纸张最多，但是别的资源几乎没有😂</p><p>在组长的带领下，我们使用直尺代替剪刀裁剪纸张，使用指甲痕代替铅笔绘制裁剪线，生产了一些不合格的产品😂。正一筹莫展之际，隔壁最穷组找到我们，他们愿意把生产的物资的一半加一个宝箱给我们，条件是把我们手里的资源都给他。我们财大气粗的组长同意了，全组人都成了甩手掌柜，当上了资本家😀。</p><p>宝箱是简单的三位数字密码锁，经过简单的尝试后，我们打开了空宝箱😂。</p><p>临近结束时，隔壁组给我们送来了几个三角形，他们说其他的因为裁剪不合格报废了。</p><p>最终隔壁组拿到了第一名，原来宝箱里的奖励是“所有正方形价格翻倍”，隔壁组凭借着‘租借’的资源以及宝箱奖励成为了最富的人😀</p><p>当然，我们组也不是最后一名，因为有个组为了购买拍卖的纸张破产了🤔（文笔不好，见谅）</p><h3 id="入职"><a class="markdownIt-Anchor" href="#入职"></a> 入职</h3><p>很快到了入职的日子，我有幸分到了ios开发组，结识了益智兄，还遇到了聪哥、我的导师曾哥。不过有个很尴尬的事情是：我一直都不知道进入公司后会做ios开发😂，也就是说在公司的发展方向与我自己希望的发展方向存在出入。</p><p>四个月的实习期很快，也很顺利的过去了，在这期间，我摸到了ios开发的门槛，基本掌握了简单ios应用、游戏的开发。（仅限使用swift语言，Object-C确实难搞啊😂）</p><h3 id="离职"><a class="markdownIt-Anchor" href="#离职"></a> 离职</h3><p>为什么五个月就从普联离职？ 我认为原因有三个：</p><ul><li>个人比较偏向后端等与界面交互不紧密的开发方向</li><li>知乎上一些关于公司不成熟的言论影响了我的判断</li><li>个人心里没B数😂，加上知乎鼓吹年轻人尝试😭</li></ul><p>在Boss直聘上挂上自己的简历后，找到了一份华为松山湖的岗位。Hr跟我说岗位是“linux应用开发”，还跟AI相关呢</p><p>记得离职时，我的直接领导（比我大五六岁）提醒我，我对取华为到底做什么其实一无所知，其次，可以考虑在公司内转岗。额，我觉得麻烦同事不太好，俺还是自己闯闯吧😀</p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>确实是太年轻了，说实话普联作为一个 865的公司，薪资也高，这么随意就丢掉了这份工作，也就我这样的脑残做的出来了😂。千万不要被知乎迷惑啊。。。。</p><h2 id="在华为的五个月"><a class="markdownIt-Anchor" href="#在华为的五个月"></a> 在华为的五个月</h2><p>华为因为招聘策略改变的缘故，当年九月之后所有社招员工均以od的形式发放offer，我也成为了其中的一员。</p><h3 id="入职-2"><a class="markdownIt-Anchor" href="#入职-2"></a> 入职</h3><p>记得我入职时，我的导师翔宇哥提前一天帮我把办公用具带到了工位，团队的pl也对我非常照顾。华为给我的感觉是团队之间的联系很紧密。小团队内经常一起去食堂吃饭、散步、回家。在普联时，我基本是跟益智一起去吃饭，在这边就是好多人一起去吃饭了。我想这也是华为能加班这么晚的原因：在公司跟在家一样，所以也没有早回家的需求了。</p><p>不过我很快发现了一个问题：团队内只有两个开发😂(算上我)，其次是我所在的团队与大部门的团队不在一起，相当边缘😂。</p><p>开发的产品使用的技术很老旧，并没有用到什么框架，不过还好是Java开发（有一说一确实是linux应用开发😂）</p><p>之后的几个月，团队逐渐招了更多开发进来，很多经验丰富的开发人员加入了我们的项目。pl也搞了个新员工知识分享，大家在吃过晚饭后，分享一些工作中涉及到的有用的小技巧。（其实主要是东伟哥、黄杰哥分析他们的经验给我们😀）</p><p>东伟哥对我们的项目架构进行了调整，使用了CQRS 消息队列等技术，项目瞬间高大上起来(<em><sup>_</sup></em>)</p><h3 id="离职-2"><a class="markdownIt-Anchor" href="#离职-2"></a> 离职</h3><p>额，这次离职的原因嘛，我个人认为一是薪资低了不少；二是职位挂在od下，没有前途可言；三是我想回长江三角洲🤩</p><h3 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h3><p>离职这种事情，还是慎重的好。随随便便离职真的顶不住啊😂 。</p><p>华为内部很注重编码能力，所有员工都要在leetCode刷题，也是在华为的经历，我认识到了刷题的重要性。</p><p>其次，知识的积累也很重要，也正是处于这个原因，我搭建了自己的博客</p><h1 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h1><p>发现自己的写作水平以及无限趋近于零了 😭 ，好好努力把 小伙子</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E5%B8%83%E5%91%97%E5%87%BB%E5%9E%AE.jpg" alt="img" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【树、图】深度广度算法全解析</title>
      <link href="/2020/07/28/%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E7%AE%97%E6%B3%95%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/07/28/%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E7%AE%97%E6%B3%95%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一只名叫孟德的鸡</title>
      <link href="/2020/07/28/%E4%B8%80%E5%8F%AA%E5%90%8D%E5%8F%AB%E5%AD%9F%E5%BE%B7%E7%9A%84%E9%B8%A1/"/>
      <url>/2020/07/28/%E4%B8%80%E5%8F%AA%E5%90%8D%E5%8F%AB%E5%AD%9F%E5%BE%B7%E7%9A%84%E9%B8%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一只名叫孟德的鸡"><a class="markdownIt-Anchor" href="#一只名叫孟德的鸡"></a> 一只名叫孟德的鸡</h1><p>这篇文章是我在华为工作时，作者发布到心声社区的，那时作者离职了，走前留下了一篇文章。写的确实不错，摘录在这里，有兴趣的话可以读一读。</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">我现在生活在一座有着几百万人口的村子里。天空永远是灰蒙蒙的，仿佛患有咽炎的天公，随口所吐了一坨老痰，笼罩在如蚁众生的头顶。村里到处是工地，渣土车像黄色的怪兽，从四处出发，又目空一切地分赴四方，身后尘土飞扬、黑烟滚滚，留下一团团经年不散的雾霾。在这里只有黑夜和白天的区别，很难看出晴天和阴天有什么不同。村道两旁的树木风尘仆仆，仿佛刚刚经过泥浴，每一片树叶，每一根树枝，都像是用泥浆浇铸而成。柏油马路早已失去了昔日黝黑的本色，此时更像是洪水漫过的旧河床，上面淤积凝结了一层厚厚的泥沙。村民们将生活垃圾堆积在路口，散发着腐烂水果和发霉饭菜所特有的怪味，随着各色的塑料袋四散漫延。如若有幸遇到大雨，你便会看到一江洪水从眼前浩浩流过，隐约间还泛发着一阵阵或浓或淡的泔水味，此时便难免悲哀，原来我生活在一桶泔水中啊！</span><br><span class="line">   </span><br><span class="line">   我年少时也住在村里。除去农忙季节和过年的时候，村里的男人大多外出，在本地或外省的工地上打工，那时他们还没有农民工的称谓， 也没有进城务工人员这样尊严体面的头衔。妇女们多半留守在家----种地、伺领孩子，当然，若是在主旋律作家的笔下，还会加上一条：奉养公婆。之所以说大多男人和妇女如此，是因为还有个别壮年男人常年在家，搓搓麻将，打打纸牌，醉后到寡妇门口耍耍酒疯，万不得已时也会去田里劳作一番，同时，也有少量妇女外出务工，以补贴家用。我想，如若仅从社会分工的角度来区分男女，那一定是上帝跟他们开了个玩笑。</span><br><span class="line"></span><br><span class="line">   村民们除了种地和外出打工外，也会在家饲养一些禽畜，如牛驴、猪羊、鸡鸭等，不一而足。这些禽畜的命运是悲哀的，从它们一出生便注定了要度过悲惨的一生。生活在拥挤、潮湿、臭气熏天的恶劣环境中，吃着其它物种淘汰下来的残渣，却要忍受毕生的劳役，或坐等被宰杀的日子一天天逼近。仅以鸡为例，母鸡的工作主题便是日复一日地下蛋，公鸡则只能坐待某日被献上祭台，或端上餐桌，终其一生，没有任何其它希望。没有一种悲哀更能令自己沮丧、惶恐了，那便是忍看被注定的命运向自己逼近却又无力更改，而这命运又是如此悲惨！</span><br><span class="line"></span><br><span class="line">   但，回首看看村民们的命运，也并不比鸡鸭好到哪里去。那些在工地上打工的人们，日复一日干着繁重的体力活，从未体验过八小时工作制，以及周末双休为何物。岁月的风霜在他们脸上留下了显而易见的痕迹，犹如经过刀劈斧砍的松木。那黝黑木然的脸庞布满了皱纹，像是纵横的沟壑，壅塞着积年的粉尘与污泥。盛夏季节，很多人每天都要喝下去两大桶凉水，以解渴消暑。那用以饮水的桶，则是刚刚刷完油漆留下的，桶壁上依然凝结着残余的漆块，水面上泛着一层薄薄的松脂色油腻，凑上前去，还会闻到一缕刺激眼鼻的气味。好在他们并不知道它的危害，从而减少了一份徒劳无功的愤怒，和惨白无力的忧虑。这对他们而言，未尝不是一件好事，许多事情，既然知道了也是无可奈何，又何苦徒增烦恼。这世界上再耀眼炙热的光芒，也照不到他们所处的黑暗阴冷的角落。世上最易压迫与剥削的无外乎这种沉默无知的奴隶，他们一如千百年来的祖辈，唯唯懦懦、苟且偷生，一代又一代重复着千百年来被注定的命运，却无任何去试图更改的尝试。眼见着可以预见的未来，一天天变成惨淡的现实，就如同忍看死神一步步向自己逼近，而又呆若木鸡、无动于衷。他们看似活着，其实早已死亡，从那开始安于可以预见的未来的一刻起，便已静候于墓地，等待死神的光临。</span><br><span class="line"></span><br><span class="line">   那时候我家后院也养有十几只鸡，有三五只是公鸡，其余均是母鸡。按照往年的惯例，所有的公鸡都会在当年年底被宰杀，除却用以祭祀灶神外，还要招待春节期间往来的亲友。但也有例外，有一年鸡群当中就有一只鸡，是从前一年遗留下来的。小年那天，当另外几只鸡束手就擒时，它从鸡圈的破损处逃离了出去，从而摆脱了和其它公鸡同样的命运。我当时还在读中学，课本中有一篇《赤壁之战》，曹操败后狼狈而逃，其仓惶状与此鸡颇为神似，我便不顾亵渎先贤的忌讳，称这只鸡为孟德。后来读了《三国演义》，看到曹操和我家孟德机敏无二，这个称呼更是让我倍感贴切。当然，华容道后来被家兄给堵上了，我当时又开始担心，下次孟德该如何逃脱。</span><br><span class="line"></span><br><span class="line">   也许是因为年长一岁的缘故，孟德的鸡冠已不复火焰般鲜红，像一抹淡淡的血液凝结在上面而呈现绛紫色，仔细看去，就会发现有细小的暗紫色血痂星列其上，那是和其它公鸡争斗时留下的。曾经灵动机警的双眼日渐变得清澈凌冽，偶泛寒光之余更多的是淡然。身上的羽毛已不再有朝霞般绚烂夺目的光焰，更像夕阳西下后徘徊于天边的暮云，厚重的质感镀上了金边，又如反射着阳光的紫铜，闪耀着沉着的光泽。每当有阳光倾泻于栏中，众鸡拥挤在一角，懒洋洋地爬卧着，孟德便在墙脚的阳光下散步。只见它尾羽微翘，双翅紧收，颈项稍稍前倾，支撑着昂扬的头颅。鸡爪轻轻收起，略作悬停，随后往前迅疾一探，继而稳稳地踩下去，反复如是，在四五米长的墙脚下来回踱步。其神其态，仿佛一位微熏的伟岸老者，拥着丰腴高挑的中年女伴，在音乐中悠然起舞。老人红光满面、皓发似雪，女伴雍容蔼蔼、风韵翩翩，入目之中，不仅是赏心悦目的艺术美感，更是浸透了岁月沧桑的优雅与恬淡。我想，与其说是岁月给孟德带来了这种风姿，不若说是岁月中的风霜与经历，给了它一颗平和宁静的心。</span><br><span class="line"></span><br><span class="line">   那年秋日的某一下午，晴光四溢，天风浩荡，如丝如缕的白云在万里碧空缓缓漂移，如新生的杨絮浮游于无际的水面。也许西北的风中总是裹挟着细微的尘沙，天空并非清澈透明的蓝，像是用河畔纯净的细沙轻轻打磨了一遍，隐隐泛着一抹淡淡的银辉，增添了几分婉约的迷蒙。鸡群从栏中放出，在院北的墙脚下，或觅食，或懒散地晒着阳光。几只公鸡不安分地跳上一辆倚墙而立的自行车，静静地闭目养神，享受着难得的自由，孟德也在其中。出于一种无聊，我突然向鸡群猛地一冲，恶作剧地大吼一声，群鸡大惊，鼠窜而散。与此同时，忽见一只鸡从自行车上腾空而起，扑扇着翅膀奋力飞上墙沿，挣扎了一番，终于稳稳地站在墙头。面朝阳光，扬首而立，为之四顾，为之踌躇满志，原来是孟德。</span><br><span class="line"></span><br><span class="line">   我想，它一定在腾起的一瞬，感受到了风的速度，它一定在墙头，看到了更广阔的大地，和更高远的天空。在那一刻，我看到它的翅尖闪烁着自由的光辉，仿佛有万千只金色的喇叭齐声长鸣，有万千束金色的阳光穿透长空，那是为它奏响的华章，为它绽放的火焰。我看到，不甘的魂灵，闪耀着生命尊严的荣光。</span><br><span class="line"></span><br><span class="line">   此后，孟德便自由了。每逢天气晴朗、风光和畅的日子，它便会从鸡栏中跃出，到宽广的天地中享受独属于它的自由。我也不再为它的命运担心，那些困住庸众的围栏，已不再是它生命中的樊篱。每次家中来亲友时，孟德都会主动跑到院后的田野中去，直到亲友离开才会回来。有时我会担忧，怕它在外面吃不饱，便时常从粮仓中拿出上好的小麦喂它，任栏中的鸡群焦躁地鸣叫而置之不理。待孟德吃完，我再拿出剩饭或麸糠给其它鸡群进食，它们既然无可奈何，不久便也安之若素了。有时候过了饭点，仍未见孟德回来，我知道，它一定是在田间地头吃饱了，那里有新鲜的菜叶和爬虫，以及甘怡的晨露。</span><br><span class="line"></span><br><span class="line">   小年又到了。尽管此前家人多次提到一定要拿孟德祭灶，但我丝毫不为它担忧，那些在群鸡眼中不可逾越的障碍，在孟德面前不过是用以表演的道具罢了，它的观众有我，还有同类的鸡群。果然，小年那日清早，当家兄蹑手蹑脚走向鸡栏，甫一靠近，孟德便从栏中跳出，一溜烟逃到院后的田野中去了。是时天气寒冷，浇过冬水的田地中早已结冰，加之家兄身形肥拙，只能任孟德逍遥而去，拿另外一只鸡替代。这只鸡经年安卧于栏中，如此的命运该是它早已预料到的，然而只有这种预料中的悲惨成为难以更改的现实时，才会有痛彻心扉的悔恨，却也悔之晚矣。</span><br><span class="line"></span><br><span class="line">   那年冬天太冷了，滴水结冰，呵气凝霜。</span><br><span class="line"></span><br><span class="line">   次日早晨，当躲在草垛中的孟德被发现时，它已经冻僵了。这一次，它未能幸免。当鲜血涌出的一瞬，它突然奋力一蹬，腾然而起，扇动着翅膀跳跃起两米多高，院中风尘为之激荡，血雨洒满了墙壁和地面。它反复地跌落，又反复地跳起，如是十余次，一切方重归寂静。</span><br><span class="line"></span><br><span class="line">   孟德离去好多年了。这期间，我看到有无数人，年复一年地重复着寡淡无奇的生活，任由明日变为今日，再变为昨日，任由昨日成为今日，再成为明日。他们尚未留下记忆，就已被遗忘。倒是那只鸡腾空跃起、振翅欲飞的影子，时常在我脑海中浮现，难免让人怀念。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 精彩短文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day 4】 从 二叉树最大深度 学习编程小技巧</title>
      <link href="/2020/07/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day4/"/>
      <url>/2020/07/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day3】</title>
      <link href="/2020/07/27/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day3%E3%80%91/"/>
      <url>/2020/07/27/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day3%E3%80%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day3】逆向思维——逃离大迷宫</title>
      <link href="/2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/"/>
      <url>/2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p><font color=#FF1493 font = 10><strong>虽然没有做多少题呢，但是我已经发现了，做题，怕的不是没有思路，而是不敢尝试。</strong></font></p><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="1036-逃离大迷宫"><a class="markdownIt-Anchor" href="#1036-逃离大迷宫"></a> <a href="https://leetcode-cn.com/problems/escape-a-large-maze/" target="_blank" rel="noopener">1036. 逃离大迷宫</a></h3><p>Difficulty: <strong>困难</strong></p><p>在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 <code>(x, y)</code>，其中 <code>0 &lt;= x, y &lt; 10^6</code>。</p><p>我们从源方格 <code>source</code> 开始出发，意图赶往目标方格 <code>target</code>。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 <code>blocked</code> 上。</p><p>只有在可以通过一系列的移动到达目标方格时才返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [[0,1],[1,0]], source &#x3D; [0,0], target &#x3D; [0,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">从源方格无法到达目标方格，因为我们无法在网格中移动。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [], source &#x3D; [0,0], target &#x3D; [999999,999999]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">因为没有方格被封锁，所以一定可以到达目标方格。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= blocked.length &lt;= 200</code></li><li><code>blocked[i].length == 2</code></li><li><code>0 &lt;= blocked[i][j] &lt; 10^6</code></li><li><code>source.length == target.length == 2</code></li><li><code>0 &lt;= source[i][j], target[i][j] &lt; 10^6</code></li><li><code>source != target</code></li></ol><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析：</h2><p>本题可以抽象为，能不能通过 blocked 将网格分成互不连通的两部分，且起点与原点分别位于分割线的两侧。进一步观察所给的参数：</p><ul><li>网格大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，基本可以放弃对网格做什么操作了。</li><li>blocked.length 的范围为 [0,200] ，完全在一个可接受的范围内，可以尝试从此入手</li></ul><h2 id="方法一寻找链接原点与终点的路径"><a class="markdownIt-Anchor" href="#方法一寻找链接原点与终点的路径"></a> 方法一：寻找链接原点与终点的路径</h2><p>老实说，该方法我还没看懂，在此贴出对应的链接地址，有兴趣可以试试这种方法😂</p><p><a href="https://leetcode-cn.com/problems/escape-a-large-maze/solution/cong-zhang-ai-wu-dian-blockedru-shou-de-kuai-su-su/" target="_blank" rel="noopener">从障碍物点入手的快速算法</a></p><h2 id="方法二-逆向思维判断是否存在满足题意的路径"><a class="markdownIt-Anchor" href="#方法二-逆向思维判断是否存在满足题意的路径"></a> 方法二： 逆向思维判断是否存在满足题意的路径</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><ul><li><p>提示里提到： 0&lt;= blocked.length &lt;=200; 也就是说圈起来的面积存在最大值。</p></li><li><p>根据抽屉原理，当从该点出发可以达到的面积大于圈起来的面积时，我们可以认为该点一定在圈外。</p></li><li><p>根据以上原理，判断起点终点是否同时在圈内或圈外即可</p></li></ul><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li>注意两点都在圈内的情况</li><li>对边界进行限制（0可以取到 😂）</li></ul><h3 id="代码实现如下"><a class="markdownIt-Anchor" href="#代码实现如下"></a> 代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] aroundArray = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outNumber = <span class="number">19901</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mapLength = <span class="number">1000000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEscapePossible</span><span class="params">(<span class="keyword">int</span>[][] blocked, <span class="keyword">int</span>[] source, <span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 hashmap 管理 blocked，降低检索造成的开销</span></span><br><span class="line">        <span class="keyword">if</span> (blocked.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;String&gt; blockedTable = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] location : blocked) &#123;</span><br><span class="line">            blockedTable.add(changeArrayToString(location));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 200 个点最多限制的格子数目为： 19900，当超出该数目时，意味着超出Block可圈界限</span></span><br><span class="line">        <span class="comment">// 取 19901 作为判断基准</span></span><br><span class="line">        <span class="keyword">return</span> isInBlocked(blockedTable, source, outNumber, changeArrayToString(target)) &amp;&amp; isInBlocked(blockedTable, target, outNumber, changeArrayToString(source));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInBlocked</span><span class="params">(HashSet&lt;String&gt; blockedTable, <span class="keyword">int</span>[] source, <span class="keyword">int</span> limitsNum, String targetStr)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; aroundQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        aroundQueue.add(source);</span><br><span class="line">        <span class="comment">// 记录走过的方格的 哈希表</span></span><br><span class="line">        HashSet&lt;String&gt; walkedSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        walkedSet.add(changeArrayToString(source));</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!aroundQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] node = aroundQueue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aroundArray.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] bufferNode = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                bufferNode[<span class="number">0</span>] = node[<span class="number">0</span>] + aroundArray[i];</span><br><span class="line">                bufferNode[<span class="number">1</span>] = node[<span class="number">1</span>] + aroundArray[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(isInArray(bufferNode[<span class="number">0</span>])&amp;&amp;isInArray(bufferNode[<span class="number">1</span>])) &#123;</span><br><span class="line">                    String locStr = changeArrayToString(bufferNode);</span><br><span class="line">                    <span class="keyword">if</span>((!blockedTable.contains(locStr)) &amp;&amp; (!walkedSet.contains(locStr)))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(locStr.equals(targetStr))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        aroundQueue.add(bufferNode);</span><br><span class="line">                        num++;</span><br><span class="line">                        walkedSet.add(locStr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= limitsNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">changeArrayToString</span><span class="params">(<span class="keyword">int</span>[] location)</span> </span>&#123;</span><br><span class="line">        StringBuilder strBuild = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        strBuild.append(location[<span class="number">0</span>]);</span><br><span class="line">        strBuild.append(<span class="string">","</span>);</span><br><span class="line">        strBuild.append(location[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> strBuild.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(location &gt;= <span class="number">0</span> &amp;&amp; location &lt; mapLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>算法复杂度：</p><ul><li>如我们所见，该算法实际作用域特定情况，我们甚至可以求出他的最大运算次数，所以大概跟复杂度不沾边了😂</li><li>额外声明了两个哈希表，用于存储不能行走的方格</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>编程题不一定用到编程技巧，或者说其实算法更侧重数学</li><li>对于 “是否存在” 问题，多考虑能否通过条件证明其存在，而不是求出该路径</li></ul><h2 id="下面这篇文章侧重于编程技巧"><a class="markdownIt-Anchor" href="#下面这篇文章侧重于编程技巧"></a> 下面这篇文章侧重于编程技巧：</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day 2】 矩阵中的最长递增路径</title>
      <link href="/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/"/>
      <url>/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="329-矩阵中的最长递增路径"><a class="markdownIt-Anchor" href="#329-矩阵中的最长递增路径"></a> <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><h2 id="方法一-记忆化深度优先搜索"><a class="markdownIt-Anchor" href="#方法一-记忆化深度优先搜索"></a> 方法一： 记忆化深度优先搜索</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><p>对于本题很容易找到解题思路：</p><ul><li>找到每个位置可以到达的下个位置（构造了树结构）</li><li>找到构造的树结构所能到达的最大深度</li></ul><p>我们的树结构看起来不那么好构造，但实际上我们需要获得的是树的深度，因此：</p><ul><li>创建额外的空间存储以当前数字为根节点构造的树所能达到的最大深度</li><li>列出动态转移方程： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo>∑</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>a</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(\sum(0, around))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>around 指矩阵的四周</li></ul><p>根据思路编写实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组模拟遍历操作(也可以模拟九宫格，应该可以😂)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] besideList = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 与其在函数外部对 0、null判断，不如交给函数内部判断。 切记切记</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> sizeX = matrix.length;</span><br><span class="line">       <span class="keyword">int</span> sizeY = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] resultDeep = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;sizeX;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sizeY;j++)&#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,i,j,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxDeep;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] resultDeep)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(resultDeep[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;besideList.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> nowX = x + besideList[i];</span><br><span class="line">           <span class="keyword">int</span> nowY = y + besideList[i+<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(!isInArray(nowX,nowY,matrix))&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(matrix[x][y]&lt;matrix[nowX][nowY]) &#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,nowX,nowY,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       resultDeep[x][y] = maxDeep + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 如果返回 boolean ，最好return &#123;逻辑语句&#125; , 而不是通过 if else 返回 true 或 false</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;matrix.length&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><ul><li>时间复杂度分析： O(mn),其中 m 和 n 分别是矩阵的行数和列数。深度优先搜索的时间复杂度是 O(V+E)，其中 V 是节点数，E 是边数。在矩阵中，O(V)=O(mn)。</li><li>空间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。空间复杂度主要取决于缓存和递归调用深度，缓存的空间复杂度是 O(mn)，递归调用深度不会超过 mn。</li></ul><h3 id="遗留问题"><a class="markdownIt-Anchor" href="#遗留问题"></a> 遗留问题</h3><p><font color=#FF4500><strong> 对深度优先算法、广度优先算法没有做到掌握，将在之后的篇章给出进一步总结。</strong></font></p><h2 id="方法二拓扑排序动态规划"><a class="markdownIt-Anchor" href="#方法二拓扑排序动态规划"></a> 方法二：拓扑排序（动态规划）</h2><h2 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h2><p>类比寻找二叉树深度的算法，其本质上是 DFS 的循环实现，本题的难点在于如何找到循环的依据：</p><ul><li><p>将数组看作有向图，寻找出度为0的点（即最大点）</p></li><li><p>从所有出度为0的点进行广度优先搜索，并更新出度值，将新的出度为0的点加入搜索队列内</p></li><li><p>搜索总层数即为矩阵中最长递增路径的长度</p><p><font color=#C71585><strong>懒了没有编写对应的实现代码，直接贴了题解</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 太长了不想贴，回头自己写个再补上吧</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析：</h3><p>与方法一相同，但是实现上复杂了许多</p><h3 id="遗留问题-2"><a class="markdownIt-Anchor" href="#遗留问题-2"></a> 遗留问题：</h3><ul><li><p>「方法一」中使用了记忆化存储和深度优先搜索，这里的深度优先搜索可以替换成广度优先搜索吗？</p></li><li><p>「方法二」中基于拓扑排序对排序后的有向无环图做了层次遍历，如果没有拓扑排序直接进行广度优先搜索会发生什么？</p></li><li><p>「方法二」中如果不使用拓扑排序，而是直接按照矩阵中元素的值从大到小进行排序，并依此顺序进行状态转移，那么可以得到正确的答案吗？如果是从小到大进行排序呢？</p></li><li><p>「变式」给定一个整数矩阵，找出符合以下条件的路径的数量：该路径严格递增，切长度至少为3.矩阵边长最大为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，答案对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 取模。其他条件与题目相同。思考对应解法</p></li></ul><h4 id="答案见如下文章"><a class="markdownIt-Anchor" href="#答案见如下文章"></a> 答案见如下文章：</h4><h4 id="文章部分思路借鉴"><a class="markdownIt-Anchor" href="#文章部分思路借鉴"></a> 文章部分思路借鉴：</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/" target="_blank" rel="noopener">leetcode 官方解答</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day 1】 分割数组的最大值</title>
      <link href="/2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/"/>
      <url>/2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="410-分割数组的最大值"><a class="markdownIt-Anchor" href="#410-分割数组的最大值"></a> <a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 _m _个非空的连续子数组。设计一个算法使得这 _m _个子数组各自和的最大值最小。</p><p><strong>注意:</strong><br />数组长度 _n _满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><h1 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答"></a> 题目解答</h1><h2 id="方法一-动态规划"><a class="markdownIt-Anchor" href="#方法一-动态规划"></a> 方法一： 动态规划</h2><h3 id="分析过程"><a class="markdownIt-Anchor" href="#分析过程"></a> 分析过程</h3><h4 id="错误的状态转移方程"><a class="markdownIt-Anchor" href="#错误的状态转移方程"></a> 错误的状态转移方程</h4><p>实不相瞒，我第一眼看到该题时，思考的方法为：</p><p>创建 m 个空数组，每次将新数字添加到当前数字之和最小的空数组中。很明显这种方法是不正确的。（脑瘫行为😂）</p><h4 id="正确的状态转移方程"><a class="markdownIt-Anchor" href="#正确的状态转移方程"></a> 正确的状态转移方程</h4><p>题目中提到两个变量，连续子数组个数 m，数组内数字个数n。 我们假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示将前 i 个数字按照要求分为 j 份所能得到的最大连续和的最小值，考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，枚举 k 属于 1~j，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 可以视为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[k][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_k^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span> 中较大者，详细描述如图：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC.jpg" alt="分割数组最大值" /></p><p>根据动态转移方程编写对应代码：</p><p>值得注意的是，除了考虑 i &lt; j 的情况，还要注意i 、j 为 0 的初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">// 需要预留(0,0) 的空间，否则会因为初始的 MAX_VALUE 导致结果出错</span></span><br><span class="line">        <span class="keyword">int</span>[][] results = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=length;i++) &#123;</span><br><span class="line">            Arrays.fill(results[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免结果被MAX_VALUE</span></span><br><span class="line">        results[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化前n项和,用于快速计算连续序列的和</span></span><br><span class="line">        <span class="keyword">int</span>[] preArrayResult = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            preArrayResult[i+<span class="number">1</span>] = preArrayResult[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过三层循环 得到f[i][j] 的所有结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i, m); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    <span class="comment">// 根据递推公式转换而来</span></span><br><span class="line">                    results[i][j] = Math.min(results[i][j], Math.max(results[k][j - <span class="number">1</span>], preArrayResult[i] - preArrayResult[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面的循环同理</span></span><br><span class="line">        <span class="comment">// for(int j = 1;j&lt;=m;j++) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int i=0;i&lt;=length; i++)&#123;</span></span><br><span class="line">        <span class="comment">//         for (int k = 0; k &lt; i; k++) &#123;</span></span><br><span class="line">        <span class="comment">//             results[i][j] = Math.min(results[i][j], Math.max(results[k][j - 1], preArrayResult[i] - preArrayResult[k]));</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> results[length][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="方法二-二分查找-贪心"><a class="markdownIt-Anchor" href="#方法二-二分查找-贪心"></a> 方法二： 二分查找 + 贪心</h2><p>原理很简单，很明显我们的答案在一个可以预测的范围内：其下界大于所有数字中最大的数。其上界小于所有数字的和。即：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\in(max(a),\sum(a))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>对于排序的数组内寻找符合条件的值，自然使用二分法，配合贪心算法判断是否存在分割方法满足要求即可。</p><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><p><font color=#C71585><strong>这其实是我个人的问题，因为不常写二分查找算法的缘故，这题我加了很多判断条件才算解决</strong></font></p><ul><li>本题可以取下界却不能取上界（下界可能为问题的解）</li><li>修改边界时，对于可取边界要 +1 ： left = mid + 1;</li><li>为了避免整数溢出，最好使用 (right - left) / 2 + left 计算 mid  （我将 mid 设为了 double 类型）</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>不难判断本题的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(sum - maxn))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>类似穷举法的题目还有很多，比如一定范围内质数、符合某项规定的数字等等。可以考虑该解法减少运算量。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/1595702409237.jpeg" alt="img" /></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
          <category> 算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
