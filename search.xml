<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>乐谱幽灵公主</title>
      <link href="./2020/10/08/%E4%B9%90%E8%B0%B1%E5%B9%BD%E7%81%B5%E5%85%AC%E4%B8%BB/"/>
      <url>./2020/10/08/%E4%B9%90%E8%B0%B1%E5%B9%BD%E7%81%B5%E5%85%AC%E4%B8%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="幽灵公主"><a class="markdownIt-Anchor" href="#幽灵公主"></a> 幽灵公主</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言：</h2><p>本身是想弹 《高洁的法皇》，因为乐器原因，演奏的效果太拉垮了，完全听不出来弹的是什么😂。改为小时候印象最深的电影主题曲吧</p><h2 id="乐谱"><a class="markdownIt-Anchor" href="#乐谱"></a> 乐谱：</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/20201008180007.png" alt="" /></p><p>应该是小学一二年纪时看过这部作品，到现在还能会想起剧情。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>乐谱天空之城</title>
      <link href="./2020/10/08/%E4%B9%90%E8%B0%B1%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E/"/>
      <url>./2020/10/08/%E4%B9%90%E8%B0%B1%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="天空之城"><a class="markdownIt-Anchor" href="#天空之城"></a> 天空之城</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言：</h2><p>之所以先弹这首曲子，是因为人家教程推荐这首曲子啦 😀</p><h2 id="乐谱"><a class="markdownIt-Anchor" href="#乐谱"></a> 乐谱：</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E.png" alt="" /></p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结：</h2><p>总体而言还是很简单的，因为使用拇指琴的缘故， 低音对应正常音</p><p>挺羡慕 希达和巴斯 的</p>]]></content>
      
      
      <categories>
          
          <category> 乐谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构相关后端技术链</title>
      <link href="./2020/10/07/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%93%BE/"/>
      <url>./2020/10/07/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="架构篇-后端分布式开发工具链-简介"><a class="markdownIt-Anchor" href="#架构篇-后端分布式开发工具链-简介"></a> 架构篇 后端分布式开发工具链 简介</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言：</h2><p>不知不觉，来到新公司50天了。有幸加入正在转型的后端开发项目组，很开心。从我的视角来看，我认为我们目前使用的开发技术，就算不是最新的，也应该属于前沿技术，所以我认为还是有必要总结一下。</p><p>文章主要目的：</p><ul><li>介绍后端相关技术链</li><li>根据个人理解，指定学习路线（由浅入深嘛，大众化优先）</li><li>对有必要提供入门Demo的，编写Demo (其实是想组个服务器装装样子 🤭)</li></ul><p>下面正式开始介绍</p><h2 id="后端开发涉及技术组件图"><a class="markdownIt-Anchor" href="#后端开发涉及技术组件图"></a> 后端开发涉及技术组件图</h2><p>本图使用 <strong>plantUML</strong> 绘制</p><a class="btn-beautify button--animated red larger" href="https://gaoxiang15125.gitee.io/2020/10/07/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%93%BE/"   title="plantUML安装踩坑教程"><i class="far fa-hand-point-right fa-fw"></i><span>plantUML安装踩坑教程</span></a><p>RibbitMQ 与 Redis 并列</p><p>Spring FrameWork / Spring Boot 互补</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/toolsChain.png" alt="toolsChain" /></p><h3 id="具体技术简介"><a class="markdownIt-Anchor" href="#具体技术简介"></a> 具体技术简介：</h3><p>行百里者半九十，这次先半九十吧 ::&gt;_&lt;::<br />小菜鸡一个很难保证总结的都是正确的</p><h2 id="部署涉及技术组件图"><a class="markdownIt-Anchor" href="#部署涉及技术组件图"></a> 部署涉及技术组件图</h2>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode下PlantUML使用教程</title>
      <link href="./2020/10/07/VSCode%E4%B8%8BPlantUML%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>./2020/10/07/VSCode%E4%B8%8BPlantUML%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下plantuml安装-使用总结"><a class="markdownIt-Anchor" href="#windows下plantuml安装-使用总结"></a> Windows下PlantUML安装、使用总结</h1><p><font color=pink><strong>所有教程均可通过官网获得</strong></font></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言：</h2><p>之前一直使用 StarUML 作为 UML 绘图工具，总体上给人的感觉是：</p><ul><li>需要大量繁杂的拖拽、拉扯工作</li><li>需要不停的在 拖拽连线、添加属性码字切换(涉及右手不停的从鼠标切换到键盘)</li><li>做出来的图片不好看，而且还收费 🙂</li><li>体验不到程序员的优势了 😭</li></ul><p>经高人指点，获悉 PlantUML 这一工具，粗浅的了解后，大概明白这是一款类似 MarkDown语法写作的UML写作工具，这么符合程序员胃口的东东，我实在没有拒绝的理由 🤭</p><div class="note info flat"><p>作为一款辅助办公的工具，自然不会有很高的门槛；</p><p>官网亦有相当详细的教程，并没有使用上的障碍</p></div><h2 id="安装-plantuml"><a class="markdownIt-Anchor" href="#安装-plantuml"></a> 安装 PlantUML</h2><ul><li>安装 Java 运行环境，保证 java 命令可用</li><li><a href="https://www.graphviz.org/download/" target="_blank" rel="noopener">graphiz-dot</a> 图形可视化工具，官网 <strong>建议和推荐</strong> 安装</li><li>设置环境变量 GRAPHVIZ_DOT ，值为上述 graphiz-dot 安装路径</li></ul><p>本打算通过 winget 包管理工具安装 graphiz-dot,不过看起来 微软还没有推广 winget，最终选择直接下载安装包</p><ul><li>下载 <a href="http://sourceforge.net/projects/plantuml/files/plantuml.jar/download" target="_blank" rel="noopener">plantuml.jar</a> 运行即可使用</li></ul><p>基本语法到官网学习为上：</p><p><a href="https://plantuml.com/zh/" target="_blank" rel="noopener">plantUML 官网</a></p><h2 id="vscode-安装-plantuml-插件"><a class="markdownIt-Anchor" href="#vscode-安装-plantuml-插件"></a> VSCode 安装 PlantUML 插件</h2><p>官网推荐了两款插件：</p><p><a href="https://marketplace.visualstudio.com/items?itemName=okazuki.okazukiplantuml" target="_blank" rel="noopener">Visual Studio Code plugin</a></p><p>作者 大田和树，让我想起了 大和田常务 🙂</p><p><a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml" target="_blank" rel="noopener">PlantUML</a></p><p>作者 jebbs</p><p>后者使用人数最多，我也安装后者🙂；我想后者用的人多，应该不仅因为功能做的好，人家名字起的这么简单直接，大家自然将其作为首选</p><h2 id="关于-vscode-下编写-plantuml"><a class="markdownIt-Anchor" href="#关于-vscode-下编写-plantuml"></a> 关于 VSCode 下编写 PlantUML</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/plantUml%E6%8F%92%E4%BB%B6%E6%88%AA%E5%9B%BE.png" alt="" /></p><p>按照插件提示：</p><ul><li>创建 .pu/.puml 等后缀名文件</li><li>编写 uml 语法</li><li>alt+d 预览</li><li>右键导出为图片</li><li>over</li></ul><h2 id="markdown-支持-plantuml-语法"><a class="markdownIt-Anchor" href="#markdown-支持-plantuml-语法"></a> MarkDown 支持 plantUML 语法</h2><p><a href="https://github.com/mikitex70/plantuml-markdown">plantuml-markdown 插件地址</a></p><p>粗略的看了下，该插件需要 python-markdown支持</p><p>问题在于本人要在博客内使用 <strong>目前有且仅有在该处有需求</strong> 因此暂时不做尝试 嘿嘿</p><h2 id="hexo-支持-plantuml-语法"><a class="markdownIt-Anchor" href="#hexo-支持-plantuml-语法"></a> Hexo 支持 plantUML 语法</h2><p>我相信 <strong>哪里有需求，哪里就有人做</strong> 对于 Hexo，自然会有对应的支持的</p><p>粗略的搜索了下，果然找到了一篇教程，搬过来介绍下 （小标题结尾处注明出处）</p><ul><li>按照上文正常配置运行环境</li><li>执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-plantuml --save</span><br></pre></td></tr></table></figure><ul><li>通过标签声明 plantUml语法区域</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">响子-&gt;盾子 : interesting</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><p>over</p><p>实际效果如下：</p><img  src= "/img/loading.gif" data-lazy-src=http://www.plantuml.com/plantuml/svg/Upgvz-dQ2RfspsVl0z8ALWgPUIMfHQd59PbvwG00><p><a href="https://github.com/two/hexo-tag-plantuml">插件地址</a></p><p>好久没更新了，大概是比较简单不需要过多维护的缘故吧</p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结：</h2><p>前面也说了，小工具，门槛非常低，依样画葫芦即可</p><p>作为 新人程序员，要多找找提高效率的工具为上 🤭</p><p>over</p><h2 id="实际使用过程中发现的问题"><a class="markdownIt-Anchor" href="#实际使用过程中发现的问题"></a> 实际使用过程中发现的问题</h2><h3 id="环境变量问题"><a class="markdownIt-Anchor" href="#环境变量问题"></a> 环境变量问题：</h3><p>不知道官网抽什么风，猜测是翻译问题。按照官网配置环境变量不成功。</p><p>不配置该环境变量，使用 Graphviz 安装过程自动添加环境变量 / 手动将 bin 目录 加到 path 中</p><h3 id="vscode-内使用版本问题"><a class="markdownIt-Anchor" href="#vscode-内使用版本问题"></a> VSCode 内使用版本问题：</h3><p>本质是因为插件内置 pantUML版本落后，修改配置，指定到我们的 plantUML.jar 即可</p><h3 id="graphviz-自动化配置"><a class="markdownIt-Anchor" href="#graphviz-自动化配置"></a> Graphviz 自动化配置</h3><p>报错信息如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/GraphViz.png" alt="GraphViz" /></p><p><strong>运行管理员权限命令行</strong> 执行 dot -c 命令：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4.png" alt="执行命令" /></p><p>ok，大功告成：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E6%88%90%E5%8A%9F.png" alt="成功" /></p><p>当然不处理也无所谓，反正咱们是用 hexo实现的</p><div class="note info flat"><p>很明显 hexo 是通过网上服务器生成图片的<br />这样的好处大概是本地没有 pantUml 的时候，也能画图 😂</p></div><h2 id="到底插入图片还是使用语法"><a class="markdownIt-Anchor" href="#到底插入图片还是使用语法"></a> 到底插入图片还是使用语法</h2><p>实际使用过程中发现：</p><ul><li>gitHub 加载 plantUML 图片非常快</li><li>gitee 加载 plantUML 相当慢 好吧根本加载不出来，弃疗</li><li>猜测是应为前者服务器在国外，后者在国内的缘故</li></ul><p>如此，我们还是乖乖的把图片插入文字中吧<br />😔 科学无国界，但科学家是有国家的</p>]]></content>
      
      
      <categories>
          
          <category> uml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职业生涯第一年总结</title>
      <link href="./2020/10/06/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E7%AC%AC%E4%B8%80%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
      <url>./2020/10/06/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E7%AC%AC%E4%B8%80%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="2019~2020-工作-生活总结"><a class="markdownIt-Anchor" href="#2019~2020-工作-生活总结"></a> 2019~2020 工作、生活总结</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言：</h2><p>和 <strong>乔鲁诺·乔巴纳</strong> 一样，我也有一个梦想。目前还不知道如何实现，能做的也就是总结自己的见闻、记录心路历程、职业观的转变，希望会对我之后的人生有帮助</p><h2 id="听到的最多的话"><a class="markdownIt-Anchor" href="#听到的最多的话"></a> 听到的最多的话：</h2><h3 id="技术并没有那么有用"><a class="markdownIt-Anchor" href="#技术并没有那么有用"></a> 技术并没有那么有用</h3><p>作为一名初入职场的新人&amp;小镇做题家，很容易对 <strong>技术</strong> 产生错误的认识，。实际上，软件行业日新月异，很难有什么技术具有长久的生命力。</p><p>其次，作为 一个真实活着的人，生活才该是人生的主题 🙂</p><p>最后，确实有一些前沿的技术，但能真正接触到、掌握这些技术的 是绝对的少数。作为一个平凡人，能做到养家糊口，我已经很满足了呵呵 🙂</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E9%9C%80%E6%B1%82%E9%87%91%E5%AD%97%E5%A1%94.jpg" alt="马斯洛需求层次理论" /></p><p>事实上我们可以想一想那些行业巨头，比如 阿里，也是现有一个盈利的项目(电商)，之后再有高新科技项目：阿里云、阿里OS等等。</p><p>目前为止，我应该做的是：掌握一个稳定赚钱的技术。🙂</p><h3 id="选择远大于努力"><a class="markdownIt-Anchor" href="#选择远大于努力"></a> 选择远大于努力</h3><p>因为最近一年切换公司比较多，在 <strong>离职群</strong> 里，我听到最多的一句话是“选择远大于努力”。这里的选择大概是指：</p><ul><li>进了哪家公司</li><li>入了哪个部门</li><li>参加了哪个项目，学到了什么</li></ul><p>努力，大概体现在加班上。当前 996 的环境下，每个员工都要加班刀很晚，每个人都很努力。</p><p>事实上，因为所在的群是离职群，大多数人所处的位置是：将要离职/暗搓搓打算离职。至于为何离职，大概率是因为与他人比较导致对自己当前的境遇不满，所以萌生了离职的念头。基于这样的想法，难免不发出 “选择远大于努力” 的感概。</p><p>就我而言，我认为 <font color=red><strong>局部看来，选择远大于努力；整体而言，努力远大于选择</strong></font></p><h4 id="局部上"><a class="markdownIt-Anchor" href="#局部上"></a> 局部上：</h4><p>不可否认，日常工作中总会遇到不顺心的事，譬如 来自领导的压力，来自自己的压力，对未来的压力等等。当压力到达一定阈值的时候，我们就要进行取舍，这个时候我认为 <strong>正确的选择远大于努力</strong> 。毕竟 <font color=blue> <strong>很多事情是努力无法改变的</strong></font></p><p>以我为例：</p><p>在上半年我遇到了一位崇尚奋斗的领导，作为其属下的员工，我也不得不奋斗，每月工时达到了 320+小时。也就是说大概每天在公司超过13个小时。加班到 凌晨 1、2 点成为了常态。这个时候我就要做个选择：继续呆在这里，用身体换大饼，还是换一份工作 蓄势待发。我认为与其在那里 努力不如做另一个选择。而且我坚信我的选择时正确的。</p><h4 id="整体上"><a class="markdownIt-Anchor" href="#整体上"></a> 整体上：</h4><p>努力不一定有回报，但是不努力是百分百没有回报了(投胎除外)。做选择 本质上是找个更好的平台努力。大白话就不多说了 🤭</p><div class="note info flat"><p>事实上我认为，所谓努力不过就是做正确的选择。譬如：</p><ul><li>晚上要不要去健身房？</li><li>晚上要不要吃夜宵？</li><li>是打游戏还是码代码？</li></ul><p>如果能做正确的选择，也自然是水到渠成</p></div><h2 id="对离职房子的认识"><a class="markdownIt-Anchor" href="#对离职房子的认识"></a> 对离职&amp;房子的认识：</h2><p>之所以将 <strong>离职</strong> 与 <strong>房子</strong> 放到一起，是因为从我的见闻来讲，房价成为了其中不可或缺的一种因素。</p><h4 id="案例一"><a class="markdownIt-Anchor" href="#案例一"></a> 案例一：</h4><p>C9本科中科大硕的一位同事入职嵌入式部门（上海），一年后离职。原因是：</p><ul><li>认为嵌入式发展前景不如软件行业(薪资水平)</li><li>认为不可能留在上海（房价）</li><li>工作一年了，职级、薪资被本科同学完爆了</li></ul><p>计划：回合肥工作，同时转软件行业</p><h4 id="案例二"><a class="markdownIt-Anchor" href="#案例二"></a> 案例二：</h4><p>最近某位年纪相仿的同事离职了，原因是：</p><ul><li>房价高，认为没有在一线城市定居的可能</li><li>认为凭自己目前、可见的将来的发展，没有定居的可能</li><li>对自己有信心，活得累与潇洒之间，选择了潇洒 😀</li></ul><p>不得不说，我认为自己算是活得潇洒的家伙了，他比我更潇洒，对生活的管理也远胜我。自愧不如。</p><p>马云说过，离职的原因无非两种：钱，没给到位；心，委屈了。</p><p>可是随着房价的上涨，前者变得越来越不可度量。我也明白我的薪资算是可以的了，但是与我想要的相比，这些薪资不值一提；那么。我是否还要继续这样的生活呢？</p><p>要回答这个问题，我们要从案例出发。我认为俩个案例中，前者更具有参考价值，也更现实。作为家里没矿的人（😭），终究逃不过工作、加班 这条路，如何走好这条路，才是重点。</p><p>结合案例一我认为平衡 工作与房 可以通过下面几点：</p><ul><li>走一条有潜力/自己认为有潜力的职业路。就想案例一的同事那样，感觉收到了瓶颈，选择换个环境再来过。</li><li>相信郭嘉。最近略有耳闻，对于年龄超过三十岁的无房青年，整幅会提供摇号购房的机会。没准到时候就轮到我了呢🤭</li><li>积累一段时间后尝试转战二线。目前而言，交通愈发便利，购买偏远房也算一条方案</li><li>淡化需求，找个 不要求买房的女朋友，或者压根不找了 🤭</li></ul><p>当然，作为一个小年轻，谈这些有些太远了，目前我是这样的认识，说不定明年就完全不一样了，谁知道呢。</p><p>说回离职</p><p>离职意味着要重新认识团队，认识新的同事，接手新的业务，所以还是尽可能避免离职为上。</p><p>倘若当前工作与生活可以协调，长干下去自然是最佳的选择</p><h2 id="对加班的认识"><a class="markdownIt-Anchor" href="#对加班的认识"></a> 对加班的认识：</h2><p>说来可笑，刚毕业那会，我属于 <strong>名副其实</strong> 的奋斗币 😂，不让加班不行，没活干不开心 🙂；同事有讲：拿多少钱做多少事，我们这里是比较轻松的。不行不行，怕自己会错过什么，所以狠狠逼了自己一把，如愿以偿得到了加班。🤭</p><p>目前大环境 996 的情况下，不加班是不现实的，我认为关键在于 <strong>找到加班的意义</strong> 可以在加班中提升自己。</p><p>有时我也在想，倘若不加班的话，我或许能利用晚上的时间培养一些爱好，诸如 在知乎灌水、弹弹手指琴、学学口琴等等 (或者打游戏)。某种程度上，加班剥夺了我的一些可能性。</p><div class="note info flat"><p>记得刚毕业那回，我不止一次跟同样刚毕业的同事说：“回去这么早干嘛，回去也是打游戏，不如加班。”</p><p>当我的领导第一次跟我这样说时，我当即表示绝对的认同 😂</p><p>最近再次听到一位前辈这样说，这次我居然第一反应是抵触😀，人还真是善变啊</p></div><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E4%B8%8D%E5%81%9A%E4%BA%BA%E4%BA%86.jpg" alt="不做人了，JOJO" /></p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>任总最近讲过：</p><div class="note info flat"><p>我们不需要每个员工都去阅读公司的总战略，不要关注太大的事情，“不在其位，不谋其政”。如果天天跟你的主管高谈阔论，他还可能在末位淘汰时给你穿小鞋。也许你是天才，但是他听不懂。而且年轻人要多服从你的领导，多与你的团队合作，踏实做好本职工作，小事做不好，怎么能证明你能做大事呢？，我们不需要每个员工都去阅读公司的总战略，不要关注太大的事情，“不在其位，不谋其政”。如果天天跟你的主管高谈阔论，他还可能在末位淘汰时给你穿小鞋。也许你是天才，但是他听不懂。而且年轻人要多服从你的领导，多与你的团队合作，踏实做好本职工作，小事做不好，怎么能证明你能做大事呢？</p></div><p>我认为任总所言极是，作为年轻人，有梦想、好高骛远，可以理解（不年轻气盛叫年轻人嘛🤬），但是更要脚踏实地，能在工作、生活中展现出自己，之后才有可能达到别样的高度。</p><p>对个人转变如下：</p><ul><li>再也不是 “社会达尔文主义者”</li><li>对 生活/工作 有了进一步认识，摸到了平衡点</li><li>相对而言现实了一些 😂</li></ul><p>写这篇文章过程中拍死了 <strong>23</strong> 只蚊子（尸体都放到卫生纸上计数了） 为什么这边蚊子这么多？难道是因为离垃圾桶比较近？？</p><p>最近居然可以徒手抓蚊子，是天冷蚊子反应速度慢了呢，还是通过锻炼我的速度变快了呢？🙂</p>]]></content>
      
      
      <categories>
          
          <category> 心路历程总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业生涯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作杂谈IDEA创建新文件u+FEFE问题</title>
      <link href="./2020/10/06/%E5%B7%A5%E4%BD%9C%E6%9D%82%E8%B0%88IDEA%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6u-FEFE%E9%97%AE%E9%A2%98/"/>
      <url>./2020/10/06/%E5%B7%A5%E4%BD%9C%E6%9D%82%E8%B0%88IDEA%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6u-FEFE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="令人困挠的-ufeff-错误问题"><a class="markdownIt-Anchor" href="#令人困挠的-ufeff-错误问题"></a> 令人困挠的 u+FEFF 错误问题</h1><h2 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因：</h2><p>按照网上的说法，是因为IDEA之前创建的文件编码格式为 <strong>utf-8 DOM</strong>, 对于 javac而言，其只能正常编译 utf-8 编码格式的文件，因此 IDEA 检查报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned character <span class="string">'`'</span>, u+FEFF 错误 </span><br><span class="line"><span class="comment">// 具体错误描述找不到了，就这个代替吧</span></span><br></pre></td></tr></table></figure><ul><li>utf-8 DOM 会在文件头部添加 '`'符号</li><li>utf-8 编码格式不支持 ‘`’,无法显示该符号</li><li>表面上看起来什么都没有的文件，或许也藏着看不到的符号 吼吼</li></ul><h2 id="相关修改方案"><a class="markdownIt-Anchor" href="#相关修改方案"></a> 相关修改方案：</h2><h3 id="修改-java-complier-参数"><a class="markdownIt-Anchor" href="#修改-java-complier-参数"></a> 修改 java complier 参数</h3><p>通过设置，为 Javac 编译添加参数 -utf-8</p><h3 id="修改-开发环境编码格式为-utf-8"><a class="markdownIt-Anchor" href="#修改-开发环境编码格式为-utf-8"></a> 修改 开发环境编码格式为 utf-8</h3><p>一般情况下默认为 GBK 手动设置下即可</p><h3 id="特别注意"><a class="markdownIt-Anchor" href="#特别注意"></a> 特别注意</h3><p>我在做了上述修改后，并没有起到作用，新建文件依然报错</p><h3 id="修改-idea-自动添加注释-file-header"><a class="markdownIt-Anchor" href="#修改-idea-自动添加注释-file-header"></a> 修改 IDEA 自动添加注释 File Header</h3><p>确保自动添加注释文本内不好含非法字符即可</p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>本质上是个小问题，讲道理最多十分钟即可解决。</p><p>但实际上我拖了将近四十天才动手解决它  😂，由此看出</p><ul><li>我 san 值 超高</li><li>超级懒，得过且过 😂</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改test_coding插件</title>
      <link href="./2020/10/06/%E5%B7%A5%E4%BD%9C%E6%9D%82%E8%B0%88%E4%BF%AE%E6%94%B9PostgreSql%E6%8F%92%E4%BB%B6/"/>
      <url>./2020/10/06/%E5%B7%A5%E4%BD%9C%E6%9D%82%E8%B0%88%E4%BF%AE%E6%94%B9PostgreSql%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="postgresql-修改-test_decoding-插件使其仅备份指定数据库"><a class="markdownIt-Anchor" href="#postgresql-修改-test_decoding-插件使其仅备份指定数据库"></a> PostgreSQL —— 修改 test_decoding 插件使其仅备份指定数据库</h1><h2 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h2><h3 id="背景介绍"><a class="markdownIt-Anchor" href="#背景介绍"></a> 背景介绍</h3><p>PostgresSQL 配套 test_decoding 插件 9.4版本存在 bug：当进行跨表操作/事务复杂的操作（目前我没有理解）时，会产生很大的延迟。目前计划使用仅备份指定表的方式解决该问题。</p><p>C / C++ 相关</p><h3 id="个人认知"><a class="markdownIt-Anchor" href="#个人认知"></a> 个人认知</h3><p>之前并没有接触过 PostgresSQL 数据库，不过我还是很想学习下数据库的底层实现的 （大雾），也购买了对应书籍，不过还没有开始阅读。</p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结：</h2><ul><li>软件日新月异，可能的话，还是尽量的话，还是使用高版本的数据库</li><li>我还是觉得在掌握了一定东东的情况下，开发才有意义。假如根本不了解插件实现原理，直接修改，无异于瞎子摸象</li><li>下面的 如果对目录不感兴趣，可以跳过了 😂</li></ul><h2 id="插件中相关结构体"><a class="markdownIt-Anchor" href="#插件中相关结构体"></a> 插件中相关结构体</h2><p>test_decoding 内  postgres 相关数据结构</p><p>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LogicalDecodingContext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* memory context this is all allocated in */</span></span><br><span class="line">MemoryContext context;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* infrastructure pieces */</span></span><br><span class="line"><span class="comment">// 日志引用对象</span></span><br><span class="line">XLogReaderState *reader;</span><br><span class="line">ReplicationSlot *slot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReorderBuffer</span> *<span class="title">reorder</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnapBuild</span> *<span class="title">snapshot_builder</span>;</span></span><br><span class="line"></span><br><span class="line">OutputPluginCallbacks callbacks;</span><br><span class="line">OutputPluginOptions options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User specified options</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List   *output_plugin_options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User-Provided callback for writing/streaming out data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LogicalOutputPluginWriterPrepareWrite prepare_write;</span><br><span class="line">LogicalOutputPluginWriterWrite <span class="built_in">write</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Output buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StringInfoout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private data pointer of the output plugin.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span>   *output_plugin_private;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private data pointer for the data writer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span>   *output_writer_private;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * State for writing output.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span>accept_writes;</span><br><span class="line"><span class="keyword">bool</span>prepared_write;</span><br><span class="line">XLogRecPtrwrite_location;</span><br><span class="line">TransactionId write_xid;</span><br><span class="line">&#125; LogicalDecodingContext;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OutputPluginOptions</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">OutputPluginOutputType output_type;</span><br><span class="line">&#125; OutputPluginOptions;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ReorderBufferTXN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The transactions transaction id, can be a toplevel or sub xid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TransactionId xid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* did the TX have catalog changes */</span></span><br><span class="line"><span class="keyword">bool</span>has_catalog_changes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do we know this is a subxact?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span>is_known_as_subxact;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LSN of the first data carrying, WAL record with knowledge about this</span></span><br><span class="line"><span class="comment"> * xid. This is allowed to *not* be first record adorned with this xid, if</span></span><br><span class="line"><span class="comment"> * the previous records aren't relevant for logical decoding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtrfirst_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----</span></span><br><span class="line"><span class="comment"> * LSN of the record that lead to this xact to be committed or</span></span><br><span class="line"><span class="comment"> * aborted. This can be a</span></span><br><span class="line"><span class="comment"> * * plain commit record</span></span><br><span class="line"><span class="comment"> * * plain commit record, of a parent transaction</span></span><br><span class="line"><span class="comment"> * * prepared transaction commit</span></span><br><span class="line"><span class="comment"> * * plain abort record</span></span><br><span class="line"><span class="comment"> * * prepared transaction abort</span></span><br><span class="line"><span class="comment"> * * error during decoding</span></span><br><span class="line"><span class="comment"> * ----</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtrfinal_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LSN pointing to the end of the commit record + 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtrend_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LSN of the last lsn at which snapshot information reside, so we can</span></span><br><span class="line"><span class="comment"> * restart decoding from there and fully recover this transaction from</span></span><br><span class="line"><span class="comment"> * WAL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtrrestart_decoding_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Commit time, only known when we read the actual commit record.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimestampTz commit_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Base snapshot or NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Snapshotbase_snapshot;</span><br><span class="line">XLogRecPtrbase_snapshot_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * How many ReorderBufferChange's do we have in this txn.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Changes in subtransactions are *not* included but tracked separately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint64nentries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * How many of the above entries are stored in memory in contrast to being</span></span><br><span class="line"><span class="comment"> * spilled to disk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint64nentries_mem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List of ReorderBufferChange structs, including new Snapshots and new</span></span><br><span class="line"><span class="comment"> * CommandIds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_headchanges;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List of (relation, ctid) =&gt; (cmin, cmax) mappings for catalog tuples.</span></span><br><span class="line"><span class="comment"> * Those are always assigned to the toplevel transaction. (Keep track of</span></span><br><span class="line"><span class="comment"> * #entries to create a hash of the right size)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_headtuplecids;</span><br><span class="line">uint64ntuplecids;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On-demand built hash for looking up the above values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HTAB   *tuplecid_hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Hash containing (potentially partial) toast entries. NULL if no toast</span></span><br><span class="line"><span class="comment"> * tuples have been found for the current change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HTAB   *toast_hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * non-hierarchical list of subtransactions that are *not* aborted. Only</span></span><br><span class="line"><span class="comment"> * used in toplevel transactions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_headsubtxns;</span><br><span class="line">uint32nsubtxns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Stored cache invalidations. This is not a linked list because we get</span></span><br><span class="line"><span class="comment"> * all the invalidations at once.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint32ninvalidations;</span><br><span class="line">SharedInvalidationMessage *invalidations;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---</span></span><br><span class="line"><span class="comment"> * Position in one of three lists:</span></span><br><span class="line"><span class="comment"> * * list of subtransactions if we are *known* to be subxact</span></span><br><span class="line"><span class="comment"> * * list of toplevel xacts (can be a as-yet unknown subxact)</span></span><br><span class="line"><span class="comment"> * * list of preallocated ReorderBufferTXNs</span></span><br><span class="line"><span class="comment"> * ---</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_nodenode;</span><br><span class="line"></span><br><span class="line">&#125; ReorderBufferTXN;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ReorderBufferTXN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The transactions transaction id, can be a toplevel or sub xid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TransactionId xid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* did the TX have catalog changes */</span></span><br><span class="line"><span class="keyword">bool</span>has_catalog_changes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do we know this is a subxact?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span>is_known_as_subxact;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LSN of the first data carrying, WAL record with knowledge about this</span></span><br><span class="line"><span class="comment"> * xid. This is allowed to *not* be first record adorned with this xid, if</span></span><br><span class="line"><span class="comment"> * the previous records aren't relevant for logical decoding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtrfirst_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----</span></span><br><span class="line"><span class="comment"> * LSN of the record that lead to this xact to be committed or</span></span><br><span class="line"><span class="comment"> * aborted. This can be a</span></span><br><span class="line"><span class="comment"> * * plain commit record</span></span><br><span class="line"><span class="comment"> * * plain commit record, of a parent transaction</span></span><br><span class="line"><span class="comment"> * * prepared transaction commit</span></span><br><span class="line"><span class="comment"> * * plain abort record</span></span><br><span class="line"><span class="comment"> * * prepared transaction abort</span></span><br><span class="line"><span class="comment"> * * error during decoding</span></span><br><span class="line"><span class="comment"> * ----</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtrfinal_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LSN pointing to the end of the commit record + 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtrend_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LSN of the last lsn at which snapshot information reside, so we can</span></span><br><span class="line"><span class="comment"> * restart decoding from there and fully recover this transaction from</span></span><br><span class="line"><span class="comment"> * WAL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtrrestart_decoding_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Commit time, only known when we read the actual commit record.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimestampTz commit_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Base snapshot or NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Snapshotbase_snapshot;</span><br><span class="line">XLogRecPtrbase_snapshot_lsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * How many ReorderBufferChange's do we have in this txn.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Changes in subtransactions are *not* included but tracked separately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint64nentries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * How many of the above entries are stored in memory in contrast to being</span></span><br><span class="line"><span class="comment"> * spilled to disk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint64nentries_mem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List of ReorderBufferChange structs, including new Snapshots and new</span></span><br><span class="line"><span class="comment"> * CommandIds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_headchanges;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List of (relation, ctid) =&gt; (cmin, cmax) mappings for catalog tuples.</span></span><br><span class="line"><span class="comment"> * Those are always assigned to the toplevel transaction. (Keep track of</span></span><br><span class="line"><span class="comment"> * #entries to create a hash of the right size)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_headtuplecids;</span><br><span class="line">uint64ntuplecids;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On-demand built hash for looking up the above values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HTAB   *tuplecid_hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Hash containing (potentially partial) toast entries. NULL if no toast</span></span><br><span class="line"><span class="comment"> * tuples have been found for the current change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HTAB   *toast_hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * non-hierarchical list of subtransactions that are *not* aborted. Only</span></span><br><span class="line"><span class="comment"> * used in toplevel transactions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_headsubtxns;</span><br><span class="line">uint32nsubtxns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Stored cache invalidations. This is not a linked list because we get</span></span><br><span class="line"><span class="comment"> * all the invalidations at once.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint32ninvalidations;</span><br><span class="line">SharedInvalidationMessage *invalidations;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---</span></span><br><span class="line"><span class="comment"> * Position in one of three lists:</span></span><br><span class="line"><span class="comment"> * * list of subtransactions if we are *known* to be subxact</span></span><br><span class="line"><span class="comment"> * * list of toplevel xacts (can be a as-yet unknown subxact)</span></span><br><span class="line"><span class="comment"> * * list of preallocated ReorderBufferTXNs</span></span><br><span class="line"><span class="comment"> * ---</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_nodenode;</span><br><span class="line"></span><br><span class="line">&#125; ReorderBufferTXN;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 XLogRecPtr;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   </span><br><span class="line">MemoryContext context;   </span><br><span class="line"><span class="keyword">bool</span>      include_xids;   </span><br><span class="line"><span class="keyword">bool</span>      include_timestamp;   </span><br><span class="line"><span class="keyword">bool</span>      skip_empty_xacts;   </span><br><span class="line"><span class="keyword">bool</span>      xact_wrote_changes;</span><br><span class="line">&#125; TestDecodingData;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringInfoData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>   *data;</span><br><span class="line"><span class="keyword">int</span>len;</span><br><span class="line"><span class="keyword">int</span>maxlen;</span><br><span class="line"><span class="keyword">int</span><span class="built_in">cursor</span>;</span><br><span class="line">&#125; StringInfoData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> StringInfoData *StringInfo;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">NodeTagtype;</span><br><span class="line">List   *names;<span class="comment">/* qualified name (list of Value strings) */</span></span><br><span class="line">OidtypeOid;<span class="comment">/* type identified by OID */</span></span><br><span class="line"><span class="keyword">bool</span>setof;<span class="comment">/* is a set? */</span></span><br><span class="line"><span class="keyword">bool</span>pct_type;<span class="comment">/* %TYPE specified? */</span></span><br><span class="line">List   *typmods;<span class="comment">/* type modifier expression(s) */</span></span><br><span class="line">int32typemod;<span class="comment">/* prespecified type modifier */</span></span><br><span class="line">List   *arrayBounds;<span class="comment">/* array bounds */</span></span><br><span class="line"><span class="keyword">int</span>location;<span class="comment">/* token location, or -1 if unknown */</span></span><br><span class="line">&#125; TypeName;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OID 目测是个枚举类型</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tupleDesc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>natts;<span class="comment">/* number of attributes in the tuple */</span></span><br><span class="line">Form_pg_attribute *attrs;</span><br><span class="line"><span class="comment">/* attrs[N] is a pointer to the description of Attribute Number N+1 */</span></span><br><span class="line">TupleConstr *constr;<span class="comment">/* constraints, or NULL if none */</span></span><br><span class="line">Oidtdtypeid;<span class="comment">/* composite type ID for tuple type */</span></span><br><span class="line">int32tdtypmod;<span class="comment">/* typmod for tuple type */</span></span><br><span class="line"><span class="keyword">bool</span>tdhasoid;<span class="comment">/* tuple has oid attribute in its header */</span></span><br><span class="line"><span class="keyword">int</span>tdrefcount;<span class="comment">/* reference count, or -1 if not counting */</span></span><br><span class="line">&#125;*TupleDesc;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint32t_len;<span class="comment">/* length of *t_data */</span></span><br><span class="line">ItemPointerData t_self;<span class="comment">/* SelfItemPointer */</span></span><br><span class="line">Oidt_tableOid;<span class="comment">/* table the tuple came from */</span></span><br><span class="line">HeapTupleHeader t_data;<span class="comment">/* -&gt; tuple header and data */</span></span><br><span class="line">&#125; HeapTupleData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> HeapTupleData *HeapTuple;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Relation  用的地方太多，暂时不处理了</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Types of the change passed to a 'change' callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For efficiency and simplicity reasons we want to keep Snapshots, CommandIds</span></span><br><span class="line"><span class="comment"> * and ComboCids in the same list with the user visible INSERT/UPDATE/DELETE</span></span><br><span class="line"><span class="comment"> * changes. Users of the decoding facilities will never see changes with</span></span><br><span class="line"><span class="comment"> * *_INTERNAL_* actions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> ReorderBufferChangeType</span><br><span class="line">&#123;</span><br><span class="line">REORDER_BUFFER_CHANGE_INSERT,</span><br><span class="line">REORDER_BUFFER_CHANGE_UPDATE,</span><br><span class="line">REORDER_BUFFER_CHANGE_DELETE,</span><br><span class="line">REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT,</span><br><span class="line">REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID,</span><br><span class="line">REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a single 'change', can be an insert (with one tuple), an update (old, new),</span></span><br><span class="line"><span class="comment"> * or a delete (old).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The same struct is also used internally for other purposes but that should</span></span><br><span class="line"><span class="comment"> * never be visible outside reorderbuffer.c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ReorderBufferChange</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">XLogRecPtrlsn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The type of change. */</span></span><br><span class="line"><span class="keyword">enum</span> ReorderBufferChangeType action;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Context data for the change, which part of the union is valid depends</span></span><br><span class="line"><span class="comment"> * on action/action_internal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Old, new tuples when action == *_INSERT|UPDATE|DELETE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* relation that has been changed */</span></span><br><span class="line">RelFileNode relnode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* no previously reassembled toast chunks are necessary anymore */</span></span><br><span class="line"><span class="keyword">bool</span> clear_toast_afterwards;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* valid for DELETE || UPDATE */</span></span><br><span class="line">ReorderBufferTupleBuf *oldtuple;</span><br><span class="line"><span class="comment">/* valid for INSERT || UPDATE */</span></span><br><span class="line">ReorderBufferTupleBuf *newtuple;</span><br><span class="line">&#125;tp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* New snapshot, set when action == *_INTERNAL_SNAPSHOT */</span></span><br><span class="line">Snapshotsnapshot;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * New command id for existing snapshot in a catalog changing tx. Set</span></span><br><span class="line"><span class="comment"> * when action == *_INTERNAL_COMMAND_ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CommandIdcommand_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * New cid mapping for catalog changing transaction, set when action</span></span><br><span class="line"><span class="comment"> * == *_INTERNAL_TUPLECID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">RelFileNode node;</span><br><span class="line">ItemPointerData tid;</span><br><span class="line">CommandIdcmin;</span><br><span class="line">CommandIdcmax;</span><br><span class="line">CommandIdcombocid;</span><br><span class="line">&#125;tuplecid;</span><br><span class="line">&#125;data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While in use this is how a change is linked into a transactions,</span></span><br><span class="line"><span class="comment"> * otherwise it's the preallocated list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dlist_nodenode;</span><br><span class="line">&#125; ReorderBufferChange;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MemoryContextData 相关信息</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemoryContextData</span> *<span class="title">MemoryContext</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemoryContextData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 枚举v 类型</span></span><br><span class="line">NodeTagtype;<span class="comment">/* identifies exact kind of context */</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">MemoryContextMethods *methods;<span class="comment">/* virtual function table */</span></span><br><span class="line">MemoryContext parent;<span class="comment">/* NULL if no parent (toplevel context) */</span></span><br><span class="line">MemoryContext firstchild;<span class="comment">/* head of linked list of children */</span></span><br><span class="line">MemoryContext nextchild;<span class="comment">/* next child of same parent */</span></span><br><span class="line"><span class="keyword">char</span>   *name;<span class="comment">/* context name (just for debugging) */</span></span><br><span class="line"><span class="keyword">bool</span>isReset;<span class="comment">/* T = no space alloced since last reset */</span></span><br><span class="line">&#125; MemoryContextData;</span><br></pre></td></tr></table></figure><h2 id="开发环境准备"><a class="markdownIt-Anchor" href="#开发环境准备"></a> 开发环境准备</h2><h3 id="mingw-clion-搭建-windows-下开发环境"><a class="markdownIt-Anchor" href="#mingw-clion-搭建-windows-下开发环境"></a> MinGW + Clion 搭建 Windows 下开发环境</h3><p>公司通过用户权限的方式限制了办公PC所能安装的软件， VS全家桶无法使用，个人感觉 VSCode 配置比较繁杂，因此使用 Clion 作为开发 IDE。搭建过程如下：</p><ul><li>前往IDEA 官网下载并安装 Clion （30天免费试用）</li><li>前往MinGW 官网下载 MinGW 在线安装包</li><li><font color=red><strong>找一款翻墙工具</strong></font> 运行 MinGW Installer 安装所有 Base packages. （不能翻墙无法正常安装）</li><li>运行 Clion， 选择 Settings -&gt; Build,Execution,Deployment-&gt;Toolchains ，将MinGW 运行环境添加到 IDE内 （权限不允许配置环境变量）</li><li>安装 Makefile support 插件 （原生Clion 仅支持 cmake 的编译方式）</li></ul><p>至此，windows 下开发环境搭建完毕</p><div class="note info flat"><p>事实上我们的项目是基于 PostgreSQL 第三方库实现的，即使我们搭建了 Windows 下开发环境，也依然不能在windows下进行编码，甚至连代码跳转、代码提示的功能都没有 笑哭</p><p>不过好处是以后想写C程序就比较方便了 大雾</p></div><h3 id="运行环境"><a class="markdownIt-Anchor" href="#运行环境"></a> 运行环境</h3><p>使用的运行环境为：</p><table><thead><tr><th>网络环境</th><th>IP地址</th><th>系统版本</th></tr></thead><tbody><tr><td>内网</td><td>10.0.46.102</td><td>CentOS release 6.8</td></tr><tr><td>外网</td><td>10.10.80.50</td><td>CentOS release 6.9</td></tr></tbody></table><h3 id="源代码地址"><a class="markdownIt-Anchor" href="#源代码地址"></a> 源代码地址</h3><p><a href="https://github.com/postgres/postgres.git">postgres GITHUB开源仓库</a></p><h3 id="编译安装相关命令"><a class="markdownIt-Anchor" href="#编译安装相关命令"></a> 编译安装相关命令</h3><p>内网：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /data/pg_install/postgresql-9.4.4/contrib/test_decoding</span><br><span class="line">make</span><br><span class="line">su - root -c "cp /data/pg_install/postgresql-9.4.4/contrib/test_decoding/test_decoding.so /data/pgsql944/lib/test_decoding.so"</span><br><span class="line">su - postgres -c "/data/pgsql944/bin/pg_ctl -D /data/pgsql944/data restart -m fast"</span><br></pre></td></tr></table></figure><p>外网：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /data/pg_install/postgresql-9.4.0/contrib/test_decoding</span><br><span class="line">make</span><br><span class="line">cp /data/pg_install/postgresql-9.4.0/contrib/test_decoding/test_decoding.so /data/postgresql/lib/test_decoding.so</span><br><span class="line">cd /data/postgresql/bin/</span><br><span class="line">./pg_ctl -D ../data/ restart -m fast</span><br></pre></td></tr></table></figure><div class="note info flat"><p>使用 source <a href="http://xxx.sh" target="_blank" rel="noopener">xxx.sh</a> 运行，而不是 ./xxx.sh</p><p>网上说 前者会真正修改当前目录，而后者会启动子shell 运行脚本，实际目录并没有发生改变</p></div><h2 id="编码思路与潜在的问题"><a class="markdownIt-Anchor" href="#编码思路与潜在的问题"></a> 编码思路与潜在的问题</h2><h4 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言：</h4><p>水平有限，笑哭 并没有做过 C 项目，不太了解 c程序 log 实现方式，且不打算修改原 MakeFile 文件，因此直接在 原文件 test_decoding.c 内修改。</p><h4 id="总体思路"><a class="markdownIt-Anchor" href="#总体思路"></a> 总体思路</h4><ul><li>编写文件输入函数，封装为 log 相关方法，记录数据库变化过程中函数的调用流程</li><li>编写运行时间记录函数，记录每个方法运行时间</li><li>编写字符串输出、比较函数，观察每个节点解析结果与解析过程</li><li>根据白名单、黑名单对 Table 进行过滤 （目前仅限单表过滤）</li></ul><h4 id="日志记录模块实现代码"><a class="markdownIt-Anchor" href="#日志记录模块实现代码"></a> 日志记录&quot;模块&quot;实现代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取日志引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FILE *<span class="title">getSelfLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file = <span class="literal">NULL</span>;</span><br><span class="line">    file = fopen(FILE_PATH, <span class="string">"a+"</span>);</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @parameter 日志引用对象</span></span><br><span class="line"><span class="comment"> * @parameter 需要写入的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logSelfInfo</span><span class="params">(FILE *file, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(str, file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放日志引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSelfFile</span><span class="params">(FILE *file)</span> </span>&#123;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 进入函数日志记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inMethodSelfLog</span><span class="params">(FILE *file, <span class="keyword">char</span> *methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> infoStr[<span class="number">25</span>] = <span class="string">"Into method "</span>;</span><br><span class="line">    logSelfInfo(file, <span class="string">"###############################\n"</span>);</span><br><span class="line">    logSelfInfo(file, infoStr);</span><br><span class="line">    logSelfInfo(file, methodName);</span><br><span class="line">    logSelfInfo(file, <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 离开函数日志记录（同时释放资源）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outMethodSelfLog</span><span class="params">(FILE *file, <span class="keyword">char</span> *methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> infoStr[<span class="number">25</span>] = <span class="string">"Out method "</span>;</span><br><span class="line">    logSelfInfo(file, infoStr);</span><br><span class="line">    logSelfInfo(file, methodName);</span><br><span class="line">    logSelfInfo(file, <span class="string">"\n###############################\n"</span>);</span><br><span class="line">    closeSelfFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>注意事项：</p><ul><li>确保数据库账户拥有日志地址的写权限（保证日志写入不会抛出异常）</li><li>确保调用过程中关闭了文件的写入流 （避免内存泄漏）</li></ul></div><h4 id="信息打印模块实现代码"><a class="markdownIt-Anchor" href="#信息打印模块实现代码"></a> 信息打印&quot;模块&quot;实现代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印 MemoryContext 内有用信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMemoryContext</span><span class="params">(FILE *file, MemoryContext bufferContext)</span> </span>&#123;</span><br><span class="line">    logSelfInfo(file, <span class="string">"MemoryContext: "</span>);</span><br><span class="line">    logSelfInfo(file, bufferContext-&gt;name);</span><br><span class="line">    logSelfInfo(file, <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印 StringInfo 内有用信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStringInfoData</span><span class="params">(FILE *file, StringInfo stringInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *reader = stringInfo-&gt;data;</span><br><span class="line">    logSelfInfo(file, <span class="string">"StringInfo: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;stringInfo-&gt;len;i++) &#123;</span><br><span class="line">        fputc(*(reader + i), file);</span><br><span class="line">    &#125;</span><br><span class="line">    logSelfInfo(file, <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印 LogicalDecodingContext内有用信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLogicalDecodingContext</span><span class="params">(FILE *file, LogicalDecodingContext *logicalContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(logicalContext-&gt;context != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printMemoryContext(file, logicalContext-&gt;context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(logicalContext-&gt;out != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printStringInfoData(file, logicalContext-&gt;out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印函数执行消耗的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTimeCost</span><span class="params">(FILE *file, <span class="keyword">int</span> timeSpend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> numStr[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(numStr,<span class="string">"%d"</span>,timeSpend);</span><br><span class="line">    logSelfInfo(file, <span class="string">"Tine spend is : "</span>);</span><br><span class="line">    logSelfInfo(file, numStr);</span><br><span class="line">    logSelfInfo(file, <span class="string">" us.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>StringInfo 内字符串中包含NULL、ETB等特殊字符，无法按照 %s 的格式进行操作、比较</li><li>StringInfo 内定义了 len 等变量，因此决定使用 <font color=purple><strong>循环</strong></font>按字节对结构体内数据进行分析判断</li><li>之后对判断方式修改后，可以使用库函数 strcmp ，目前暂时使用自己编写的函数</li><li>结构体相关描述将在下面给出</li></ul></div><h4 id="字符串解析模块实现代码"><a class="markdownIt-Anchor" href="#字符串解析模块实现代码"></a> 字符串解析模块实现代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到对应字段在 StringInfo 内位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strSelfFind</span><span class="params">(StringInfo stringInfo, <span class="keyword">char</span> *tagChar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意越界问题，虽然 stringInfo 有保护，但还是要自己判断才好</span></span><br><span class="line">    <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tagLocation = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> infoLength = stringInfo-&gt;len;</span><br><span class="line">    <span class="keyword">char</span> *infoData = stringInfo-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(;location&lt;infoLength;location++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(tagLocation=<span class="number">0</span>;<span class="number">1</span>;tagLocation++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(*(tagChar+tagLocation))||(*(tagChar+tagLocation) == <span class="string">'\0'</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> location + tagLocation;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(*(infoData+location+tagLocation) != *(tagChar+tagLocation) || (location+tagLocation)&gt;infoLength) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一层封装</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTableLocation</span><span class="params">(StringInfo stringInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strSelfFind(stringInfo, TABLE_TAG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处本质上是根据写入的字符进行解析判断，可以优化为 写入表名时判断</span></span><br><span class="line"><span class="comment">// 降低程序复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isTableRight</span><span class="params">(StringInfo stringInfo, <span class="keyword">char</span> *tableName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tableTag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> location = findTableLocation(stringInfo);</span><br><span class="line">    <span class="keyword">char</span> *strData = stringInfo-&gt;data;</span><br><span class="line">    <span class="comment">// 跳过第一个空格</span></span><br><span class="line">    location ++;</span><br><span class="line">    <span class="keyword">while</span>(*(tableName + tableTag)!=<span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(strData + location + tableTag) != *(tableName + tableTag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tableTag++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*(strData + location + tableTag) == <span class="string">':'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关结构体"><a class="markdownIt-Anchor" href="#相关结构体"></a> 相关结构体</h3><p>由于开发环境的限制，无法直接进行代码跳转，此处直接给出相关结构体：</p><h4 id="logicaldecodingcontext"><a class="markdownIt-Anchor" href="#logicaldecodingcontext"></a> LogicalDecodingContext:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LogicalDecodingContext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* memory context this is all allocated in */</span></span><br><span class="line">MemoryContext context;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* infrastructure pieces */</span></span><br><span class="line"><span class="comment">// 日志引用对象</span></span><br><span class="line">XLogReaderState *reader;</span><br><span class="line">ReplicationSlot *slot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReorderBuffer</span> *<span class="title">reorder</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnapBuild</span> *<span class="title">snapshot_builder</span>;</span></span><br><span class="line"></span><br><span class="line">OutputPluginCallbacks callbacks;</span><br><span class="line">OutputPluginOptions options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User specified options</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List   *output_plugin_options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User-Provided callback for writing/streaming out data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LogicalOutputPluginWriterPrepareWrite prepare_write;</span><br><span class="line">LogicalOutputPluginWriterWrite <span class="built_in">write</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Output buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StringInfoout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private data pointer of the output plugin.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span>   *output_plugin_private;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private data pointer for the data writer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span>   *output_writer_private;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * State for writing output.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span>accept_writes;</span><br><span class="line"><span class="keyword">bool</span>prepared_write;</span><br><span class="line">XLogRecPtrwrite_location;</span><br><span class="line">TransactionId write_xid;</span><br><span class="line">&#125; LogicalDecodingContext;</span><br></pre></td></tr></table></figure><h4 id="testdecodingdata"><a class="markdownIt-Anchor" href="#testdecodingdata"></a> TestDecodingData:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   </span><br><span class="line">MemoryContext context;   </span><br><span class="line"><span class="keyword">bool</span>      include_xids;   </span><br><span class="line"><span class="keyword">bool</span>      include_timestamp;   </span><br><span class="line"><span class="keyword">bool</span>      skip_empty_xacts;   </span><br><span class="line"><span class="keyword">bool</span>      xact_wrote_changes;</span><br><span class="line">&#125; TestDecodingData;</span><br></pre></td></tr></table></figure><h4 id="typename"><a class="markdownIt-Anchor" href="#typename"></a> TypeName:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">NodeTagtype;</span><br><span class="line">List   *names;<span class="comment">/* qualified name (list of Value strings) */</span></span><br><span class="line">OidtypeOid;<span class="comment">/* type identified by OID */</span></span><br><span class="line"><span class="keyword">bool</span>setof;<span class="comment">/* is a set? */</span></span><br><span class="line"><span class="keyword">bool</span>pct_type;<span class="comment">/* %TYPE specified? */</span></span><br><span class="line">List   *typmods;<span class="comment">/* type modifier expression(s) */</span></span><br><span class="line">int32typemod;<span class="comment">/* prespecified type modifier */</span></span><br><span class="line">List   *arrayBounds;<span class="comment">/* array bounds */</span></span><br><span class="line"><span class="keyword">int</span>location;<span class="comment">/* token location, or -1 if unknown */</span></span><br><span class="line">&#125; TypeName;</span><br></pre></td></tr></table></figure><h4 id="memorycontext"><a class="markdownIt-Anchor" href="#memorycontext"></a> MemoryContext:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemoryContextData</span> *<span class="title">MemoryContext</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemoryContextData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 枚举v 类型</span></span><br><span class="line">NodeTagtype;<span class="comment">/* identifies exact kind of context */</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">MemoryContextMethods *methods;<span class="comment">/* virtual function table */</span></span><br><span class="line">MemoryContext parent;<span class="comment">/* NULL if no parent (toplevel context) */</span></span><br><span class="line">MemoryContext firstchild;<span class="comment">/* head of linked list of children */</span></span><br><span class="line">MemoryContext nextchild;<span class="comment">/* next child of same parent */</span></span><br><span class="line"><span class="keyword">char</span>   *name;<span class="comment">/* context name (just for debugging) */</span></span><br><span class="line"><span class="keyword">bool</span>isReset;<span class="comment">/* T = no space alloced since last reset */</span></span><br><span class="line">&#125; MemoryContextData;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机其二</title>
      <link href="./2020/08/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B6%E4%BA%8C/"/>
      <url>./2020/08/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>文章内容参考《深入理解Java虚拟机》 周志明 著</p><div class="note info flat"><p>直到看了这本书我才发现，我之前对 JVM 堆栈 的理解全是错的 😭，还好面试的时候都是直接说 不会/不了解 😂</p></div><div class="note success flat"><p>Java 虚拟机有很多类型，不同类型的虚拟机拥有不同的特性。书内介绍的为 业界的通常做法</p></div><h3 id="运行时数据区域"><a class="markdownIt-Anchor" href="#运行时数据区域"></a> 运行时数据区域</h3><p>一般情况下，Java虚拟机所管理的内存包括如下几个运行时数据区域：</p><p><img src= "/img/loading.gif" data-lazy-src="C:%5CUsers%5C63026%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200807184654415.png" alt="image-20200807184654415" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day 5】 沦为扒手的程序员</title>
      <link href="./2020/08/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%205/"/>
      <url>./2020/08/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%205/</url>
      
        <content type="html"><![CDATA[<h1 id="精神领袖附身的-程序员"><a class="markdownIt-Anchor" href="#精神领袖附身的-程序员"></a> 精神领袖附身的 程序员</h1><p>怎么偷，偷那些，这是个问题🙈🙉🙊🐵</p><h3 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍"></a> <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h3><p>Difficulty: <strong>简单</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><div class="note info flat"><p>本题比较直观，几乎可以一眼看出来使用迭代法或者动态规划，不再进行分析，直接上代码</p></div><h5 id="动态转移方程"><a class="markdownIt-Anchor" href="#动态转移方程"></a> 动态转移方程：</h5><p>​<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[n] = max(f[n-1], f[n-2] + num[n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n \in(0,nums.length)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></p><p>多 BB 一句：</p><ul><li>请详细的限制不符合公式的条件： nums == null || nums.length == 1|| nums.length == 0  避免重复运行拉低通过率 😂</li></ul><h5 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(0) = 0; f(1) = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节省内存资源，用两个数字存储结果</span></span><br><span class="line">        <span class="comment">// 前者表示 f[n-2], 后者表示 f[n-1]</span></span><br><span class="line">        <span class="keyword">int</span> numOne = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numTwo = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> resultNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 很明显越往后数字越大，遍历结束就能得到结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            resultNum = Math.max(numOne + nums[i], numTwo);</span><br><span class="line">            numOne = numTwo;</span><br><span class="line">            numTwo = resultNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultNum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="213-打家劫舍ii"><a class="markdownIt-Anchor" href="#213-打家劫舍ii"></a> <a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍II</a></h3><p>Difficulty: <strong>中等</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下，**能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><h4 id="方法一动态规划"><a class="markdownIt-Anchor" href="#方法一动态规划"></a> 方法一：动态规划</h4><div class="note info flat"><p>小小的思考：</p><p>与打家劫舍I区别在于多了 首尾的限制。我认为可以分别以第一位、第二位为起始点重复动态规划，挑选最大的结果</p></div><ul><li>注意以第一位为起始点时，不包含末尾的房屋</li></ul><h5 id="实现代码-2"><a class="markdownIt-Anchor" href="#实现代码-2"></a> 实现代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 节省内存资源，用两个数字存储结果</span></span><br><span class="line">       <span class="comment">// 前者表示 f[n-2], 后者表示 f[n-1],强制选择第一个数字</span></span><br><span class="line">       <span class="keyword">int</span> numOne = <span class="number">0</span> - nums[<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span> numTwo = nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> resultOne = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 很明显越往后数字越大，遍历结束就能得到结果</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           resultOne = Math.max(numOne + nums[i], numTwo);</span><br><span class="line">           numOne = numTwo;</span><br><span class="line">           numTwo = resultOne;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 强制选择第二个数字</span></span><br><span class="line">       numOne = <span class="number">0</span>;</span><br><span class="line">       numTwo = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> resultTwo = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           resultTwo = Math.max(numOne + nums[i], numTwo);</span><br><span class="line">           numOne = numTwo;</span><br><span class="line">           numTwo = resultTwo;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resultOne &gt; resultTwo ? resultOne : resultTwo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>虽说解决了问题，但本质上并不是严谨的动态规划 （好吧我觉得毕竟加了判断，动态规划偏 数列 的感觉）</li><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="方法二贪心算法"><a class="markdownIt-Anchor" href="#方法二贪心算法"></a> 方法二：贪心算法</h4><div class="note info flat"><p>没看太懂，还是等等再说把</p></div><p><a href="https://leetcode-cn.com/problems/house-robber-ii/solution/python3-tan-xin-suan-fa-by-ting-ting-28/" target="_blank" rel="noopener">打家劫舍贪心解法</a></p><h3 id="337-打家劫舍-iii"><a class="markdownIt-Anchor" href="#337-打家劫舍-iii"></a> <a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h3><p>Difficulty: <strong>中等</strong></p><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h4><ul><li>对于本题，经过分析不难发现，父树与子树之间满足 打家劫舍I 中的关系。</li><li>当前节点所能得到的金钱 等于<Strong>所有子树所能得到金钱的和</Strong>  与 <Strong>所有孙树所能得到的金钱的和与当前节点的和</Strong> 中的较大者</li></ul><div class="note warning flat"><p>上述第二条结论并不正确，树的特殊性决定，孙树跟子树的结合 可能大于 孙树与孙树 的结合，因此应该是：</p><p>Max(右子树、右子树的孙树) + Max(左子树、左子树的孙树)</p><p>原因： 对于本题 我们仅仅是记录了右子树的最大值、右子树孙树的最大值，并没有比较这两个值的大小</p></div><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dfs(TreeNode node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较选择当前节点与不选择当前节点所偷窃的金额差值</span></span><br><span class="line">        <span class="comment">// 偷取当前节点，则只能获得孙节点值，反之可以选择孙节点与子节点最大组合</span></span><br><span class="line">        <span class="keyword">int</span>[] leftResult = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] rightResult = dfs(node.right);</span><br><span class="line">        <span class="keyword">int</span> selectNode = leftResult[<span class="number">1</span>] + rightResult[<span class="number">1</span>] + node.val;</span><br><span class="line">        <span class="keyword">int</span> unSelectNode = Math.max(leftResult[<span class="number">0</span>], leftResult[<span class="number">1</span>]) + Math.max(rightResult[<span class="number">0</span>], rightResult[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selectNode,unSelectNode&#125;; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很尴尬 我自己并没有码出来，呵呵 ，该问题的难点在于怎么传递两个子数据</p><p><font color =purple><strong>🧠说 我悟了 手告诉你 你还差的远呢 😂</strong></font></p><ul><li>本题的难点在实现这一块，很明显对于本题要使用 <font color = purple><strong>后序遍历</strong></font> 的形式</li><li>本题处理 f[n-2] 与 f[n-1] 的具体实现方式非常巧，要学习掌握下才好</li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>打家劫舍问题很容易看出要用动态规划解决，与此相关的还有 <a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a>。 当然，这道题比较难，咱们来日再谈 😀</p><p>这一系列题目昭示了一个真理，学好编程学好算法，当小偷都比别人强  😂😂</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="./2020/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>./2020/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>目前无论哪种语言都已经提供了排序的接口，我们甚至可以自己定义比对函数实现排序功能。但是奈何排序是面试的高发题，不整理下我寝食难安啊 😂</p><h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2><ul><li>重复遍历要排序的元素列，依次比较相邻的元素，直到没有相邻的元素需要交换</li><li>实现过程：每轮比较保证将当前比较范围的最值移动到正确的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BubbleSort(<span class="keyword">int</span>[] numArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = numArray.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length - <span class="number">1</span> - i; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numArray[k] &gt; numArray[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tempNum = numArray[k + <span class="number">1</span>];</span><br><span class="line">                    numArray[k + <span class="number">1</span>] = numArray[k];</span><br><span class="line">                    numArray[k] = tempNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2><ul><li>遍历待排序的数组，每次从数据元素中选出最小值，放在序列的起始位置，直到待排序数据为空</li><li>实现过程：本质上与冒泡排序相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] SelectionSort(<span class="keyword">int</span>[] numArray) &#123;</span><br><span class="line">       <span class="keyword">int</span> length = numArray.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> tempNum = i;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (numArray[tempNum] &gt; numArray[j]) &#123;</span><br><span class="line">                   tempNum = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> temp = numArray[i];</span><br><span class="line">           numArray[i] = numArray[tempNum];</span><br><span class="line">           numArray[tempNum] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> numArray;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2><ul><li>类似玩扑克牌时整理手牌，哈哈也可以视为有目的的冒泡排序</li><li>实现过程：每次为一张牌找到正确的位置，直到所有牌到达正确的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] InsertSort(<span class="keyword">int</span>[] numArray) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = numArray.length;</span><br><span class="line">    <span class="comment">// 相比于每个数字后移一位，插入的数字与比较的数字交换更直观</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; numArray[j] &lt; numArray[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempNum = numArray[j];</span><br><span class="line">            numArray[j] = numArray[j - <span class="number">1</span>];</span><br><span class="line">            numArray[j - <span class="number">1</span>] = tempNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><ul><li>很有名的排序了，选择当前数组内的一个数字，以其为基准，将大于或小于他的数字分别移动到数组的两端，递归判断最终即可对原数组排序</li><li>感觉上跟二分法相当类似</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numArray 存储数组的引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left     比较范围左下标 (包含该下标）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right    比较范围右下标 (包含该下标)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] numArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择最右边的值作为参照，比该值小的放在左边，比该值大的放在右边</span></span><br><span class="line">    <span class="comment">// 意识到一个问题， int 数组应该是引用传递吧 😂</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m 标记了当前比目标值小的数字的个数</span></span><br><span class="line">    <span class="keyword">int</span> m = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numArray[i] &lt; numArray[right]) &#123;</span><br><span class="line">            <span class="comment">// 与传统的从两头开始比较替换不同，这里从单方向比较，虽说增加了多余的交换动作，但是代码更直观了</span></span><br><span class="line">            <span class="keyword">int</span> tempNum = numArray[i];</span><br><span class="line">            numArray[i] = numArray[m];</span><br><span class="line">            numArray[m] = tempNum;</span><br><span class="line">            m++; <span class="comment">// 标记下一个替换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将比较值移动到当前标记位置</span></span><br><span class="line">    <span class="keyword">int</span> tempNum = numArray[m];</span><br><span class="line">    numArray[m] = numArray[right];</span><br><span class="line">    numArray[right] = tempNum;</span><br><span class="line">    <span class="comment">// 分别对数组左右两侧再次进行排序</span></span><br><span class="line">    QuickSort(numArray, left, m - <span class="number">1</span>);</span><br><span class="line">    QuickSort(numArray, m + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>快速排序算法复杂度为 $O(n\log(n))，相比前面的排序在时间复杂度上有了优化</li></ul><h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2><ul><li>将数组分为两部分，分别对该两部分进行排序，再将这两部分合并为排序好的一部分</li><li>某种程度上与快速排序相同，排序的实现跟直观一些</li><li>相对于快速排序，归并排序额外申请了内存空间，将消耗更多的内存资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] numArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">       <span class="keyword">if</span> (left == right)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;numArray[left]&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span>[] leftArr = mergeSort(numArray, left, mid); <span class="comment">//左有序数组</span></span><br><span class="line">       <span class="keyword">int</span>[] rightArr = mergeSort(numArray, mid + <span class="number">1</span>, right); <span class="comment">//右有序数组</span></span><br><span class="line">       <span class="keyword">int</span>[] newNum = <span class="keyword">new</span> <span class="keyword">int</span>[leftArr.length + rightArr.length]; <span class="comment">//新有序数组</span></span><br><span class="line">       <span class="keyword">int</span> m = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) &#123;</span><br><span class="line">           newNum[m++] = leftArr[i] &lt; rightArr[j] ? leftArr[i++] : rightArr[j++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; leftArr.length)</span><br><span class="line">           newNum[m++] = leftArr[i++];</span><br><span class="line">       <span class="keyword">while</span> (j &lt; rightArr.length)</span><br><span class="line">           newNum[m++] = rightArr[j++];</span><br><span class="line">       <span class="keyword">return</span> newNum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>归并排序可以视为另一种形式的 快速排序，其算法复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>可以仅对原数组进行修改来实现归并排序，我尝试了下，太麻烦没有解决，所有直接 copy 了现成的代码</li></ul><h2 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h2><ul><li>快速排序、归并排序、希尔排序 均采用了 先对数组的部分进行排序，在对整个数组进行排序的策略</li><li>选取指定间隔长度，将数组内相同间隔长度的数分为一组，对该组内数字进行排序操作</li><li>不断减少间隔长度，重复分组并对组内数字进行排序，直到间隔减少至0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] numArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = numArray.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = length; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="comment">// 每组使用插入排序实现排序效果, 可以在复习下插入排序最好的实现方式</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j - gap &gt;= <span class="number">0</span> &amp;&amp; numArray[j] &lt; numArray[j - gap]; j -= gap) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tempNum = numArray[j];</span><br><span class="line">                    numArray[j] = numArray[j - gap];</span><br><span class="line">                    numArray[j - gap] = tempNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="计数排序不需要两两比较"><a class="markdownIt-Anchor" href="#计数排序不需要两两比较"></a> 计数排序——不需要两两比较</h2><div class="note info flat"><p>计数排序的实现有些门道，所以在此处重点描述。</p></div><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理：</h3><ul><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数排序</span><br><span class="line">public static int[] CountSort(int[] numArray) &#123;</span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for (int num : numArray) &#123;</span><br><span class="line">        max &#x3D; Math.max(max, num);</span><br><span class="line">        min &#x3D; Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    int countLength &#x3D; max - min + 1;</span><br><span class="line">    int[] countTable &#x3D; new int[countLength];</span><br><span class="line">    for (int num : numArray) &#123;</span><br><span class="line">        countTable[num - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; countLength; i++) &#123;</span><br><span class="line">        countTable[i] +&#x3D; countTable[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 从后往前遍历原数组，将排序结果写入新数组</span><br><span class="line">    int[] result &#x3D; new int[numArray.length];</span><br><span class="line">    for (int i &#x3D; numArray.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        result[countTable[numArray[i] - min] - 1] &#x3D; numArray[i];</span><br><span class="line">        &#x2F;&#x2F; 这个 -- 可是有大学问的</span><br><span class="line">        countTable[numArray[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用第三方脚本为butterfly主题添加背景音乐</title>
      <link href="./2020/07/31/Hexo%E9%9F%B3%E4%B9%90%E6%8F%92%E4%BB%B6/"/>
      <url>./2020/07/31/Hexo%E9%9F%B3%E4%B9%90%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>起先，我也是看到别人的博客才萌发了自己搭建博客的想法，说实话，博客带有音乐播放器让人感觉非常酷炫，所以我也尝试在博客中添加播放器。</p><div class="note default flat"><p>butterfly 教程中提到，个人博客要到百度、360之类的搜索引擎网站提交备案。猜测没有备案的博客网站是不会被搜索引擎收录的。想要被搜索引擎检索到，就尝试备案一下吧</p></div><h2 id="使用-hexo-tag-aplayer-插件"><a class="markdownIt-Anchor" href="#使用-hexo-tag-aplayer-插件"></a> 使用 hexo-tag-aplayer 插件</h2><p>按照 butterfly 教程提示去安装 hexo-tag-aplayer 插件后，按照插件教程添加配置信息，运行后发现并没有出现播放器😂</p><p>作为前端萌新，放弃了使用 aplayer音乐插件，转而寻找新的方法</p><h2 id="使用第三方播放器"><a class="markdownIt-Anchor" href="#使用第三方播放器"></a> 使用第三方播放器</h2><p><a href="https://blog.csdn.net/weixin_43350051/article/details/106179633" target="_blank" rel="noopener">一篇博客搞定背景音乐</a></p><p>通过百度找到了更好的解决方案，原文如上。</p><p>与作者不同的是，我使用了作者提到的一款免费的网页播放器 —— 梨花带雨播放器 (好奇怪的名字)</p><p><a href="https://music.m0x.cn/index/home/index.html" target="_blank" rel="noopener">梨花带雨播放器官网</a></p><p>具体使用方法就比较简单了，在该主页注册、创建播放器后，将播放器实现代码 clone 到配置文件的 bottom 下即可：</p><p><img src= "/img/loading.gif" data-lazy-src="C:%5CUsers%5C63026%5CDesktop%5C%E6%B7%BB%E5%8A%A0%E6%92%AD%E6%94%BE%E5%99%A8.png" alt="添加播放器" /></p><h2 id="遇到的小问题"><a class="markdownIt-Anchor" href="#遇到的小问题"></a> 遇到的小问题</h2><p>网易云内有些歌曲需要 VIP 权限才能播放，那么能不能通过手动添加自己上传的VIP歌曲来播放VIP音乐呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200731152824.png" alt="TIM截图20200731152824" /></p><ul><li>通过 QQ音乐购买单曲下载 MP3资源</li><li>通过Gitee仓库上传该资源，同时上传对应的专辑封面</li><li>添加歌曲</li></ul><div class="note default flat"><p>注意对应 的 MP3资源应该跟博客在同一仓库内，否则会因为跨域访问报错：无法加载指定资源</p></div><h1 id="写在后面的话"><a class="markdownIt-Anchor" href="#写在后面的话"></a> 写在后面的话</h1><p>经过实际使用，发现该网站提供的播放器有概率无法加载资源，且加载速度很慢，因此推荐使用下面的播放器：</p><p><a href="https://myhkw.cn/" target="_blank" rel="noopener">明月浩空播放器 </a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树结构两三事</title>
      <link href="./2020/07/30/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>./2020/07/30/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p>树结构在编程、算法中占有很重要的地位，树相关问题包括二叉树、红黑树、前序后序中序遍历、最大堆最小堆等等。在此对树结构问题做个总结。</p><h1 id="前序-后序-中序遍历相关问题"><a class="markdownIt-Anchor" href="#前序-后序-中序遍历相关问题"></a> 前序、后序、中序遍历相关问题</h1><h2 id="相关知识"><a class="markdownIt-Anchor" href="#相关知识"></a> 相关知识：</h2><ul><li>前序遍历： 先访问根节点，再访问左子节点，最后访问右子节点。</li><li>中序遍历： 先访问左子节点，在访问根节点，最后访问右子节点。</li><li>后序遍历： 先访问左子节点，在访问右子节点，最后访问根节点。</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    10</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  6    14</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">4   8 12 16</span><br><span class="line"></span><br><span class="line">前序遍历： 10 6 4 8 14 12 16</span><br><span class="line">中序遍历： 4 6 8 10 12 14 16</span><br><span class="line">后序遍历： 4 8 6 12 16 14 10</span><br></pre></td></tr></table></figure><div class="note info flat"><p>简单应用： 通过中序遍历转 前序/后序 计算 算术表达式的值</p></div><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li>掌握前序、后序、中序遍历的递归、迭代实现</li><li>知道前序、后序、中序遍历的意义，可以对其简单应用</li><li>可以通过三者之二还原树结构</li></ul><h2 id="问题一二叉树展开为链表"><a class="markdownIt-Anchor" href="#问题一二叉树展开为链表"></a> 问题一：二叉树展开为链表</h2><h3 id="114-二叉树展开为链表"><a class="markdownIt-Anchor" href="#114-二叉树展开为链表"></a> <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个二叉树，<font color=red><strong>原地</strong></font>将它展开为一个单链表。</p><p>例如，给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure><p>将其展开为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure><h3 id="方法一-前序遍历转列表"><a class="markdownIt-Anchor" href="#方法一-前序遍历转列表"></a> 方法一： 前序遍历转列表</h3><h4 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h4><p>很明显转化过程本质是对树结构的前序遍历，迭代实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果仅仅是前序遍历 肯定不符合题目要求的</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack();</span><br><span class="line">        nodeStack.add(root);</span><br><span class="line">        TreeNode buffNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nodeStack.isEmpty()) &#123;</span><br><span class="line">            buffNode = nodeStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(buffNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nodeStack.add(buffNode.right);</span><br><span class="line">                buffNode.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(buffNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeStack.add(buffNode.left);</span><br><span class="line">                buffNode.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!nodeStack.isEmpty())&#123;</span><br><span class="line">                buffNode.right = nodeStack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="残留的问题"><a class="markdownIt-Anchor" href="#残留的问题"></a> 残留的问题：</h4><ul><li>题干中存在额外要求： “原地” 的。</li><li>时间复杂度、空间复杂度均为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="方法二-寻找前驱节点"><a class="markdownIt-Anchor" href="#方法二-寻找前驱节点"></a> 方法二： 寻找前驱节点</h3><h4 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h4><ul><li>通过观察可以发现 对于任何一个节点，其右子节点在转化后位于其左子树的最右节点之后。根据思路编写实现代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode buffNode = root;</span><br><span class="line">    <span class="keyword">while</span>(buffNode != <span class="keyword">null</span> &amp;&amp; hasChildNode(root)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(buffNode.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(buffNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode fatherNode = rightMaxNode(buffNode.left);</span><br><span class="line">                fatherNode.right = buffNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">            buffNode.right = buffNode.left;</span><br><span class="line">            buffNode.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffNode = buffNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">rightMaxNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasChildNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.left != <span class="keyword">null</span> || node.right != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>递归实现方式更加直观</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">flatten(root.left);</span><br><span class="line">flatten(root.right);</span><br><span class="line">TreeNode bufferNode = root.right;</span><br><span class="line">root.right = root.left;</span><br><span class="line">root.left = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 此时的 root.right 对应原节点的左子节点</span></span><br><span class="line"><span class="keyword">while</span>(root.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">root =root.right;</span><br><span class="line">&#125;</span><br><span class="line">root.right = bufferNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="问题二重建二叉树"><a class="markdownIt-Anchor" href="#问题二重建二叉树"></a> 问题二：重建二叉树</h2><h3 id="剑指-offer-07-重建二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-07-重建二叉树"></a> <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></h3><p>Difficulty: <strong>中等</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 5000</code></p><p><strong>注意</strong>：本题与主站 105 题重复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有点难搞，等等先😂</span><br></pre></td></tr></table></figure><h2 id="问题三判断平衡二叉树"><a class="markdownIt-Anchor" href="#问题三判断平衡二叉树"></a> 问题三：判断平衡二叉树</h2><h3 id="110-平衡二叉树"><a class="markdownIt-Anchor" href="#110-平衡二叉树"></a> <a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h3><p>Difficulty: <strong>简单</strong></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树_每个节点 _的左右两个子树的高度差的绝对值不超过1。</p></blockquote><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><h3 id="方法一-我的方法概念未理解导致错误"><a class="markdownIt-Anchor" href="#方法一-我的方法概念未理解导致错误"></a> 方法一： 我的方法（概念未理解导致错误）</h3><h4 id="思路分析-3"><a class="markdownIt-Anchor" href="#思路分析-3"></a> 思路分析：</h4><p>我<font color=purple><strong>印象</strong></font>中平衡二叉树的定义为：<font color=blue><strong>叶子节点的最大深度只比最小深度多一</strong></font>,导致编码错误。</p><p>按照我的理解，设计编码思路如下：</p><ul><li>通过遍历获取所有叶子节点的深度，并按照从深到浅的顺序依次向上返回</li><li>返回内容为：当前子树的最大深度与最浅深度</li><li>返回父节点时，对两者进行比较，将子树的最大深度作为自己的最大深度；子树的最浅深度作为自己的最浅深度</li><li>返回根节点时，比较最大深度与最浅深度，差值大于一则不为完全平衡二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断方法很简单，最浅不完全层与最深树节点差值超过2，即为不完全树</span></span><br><span class="line">        <span class="comment">//  递归获取子树的深度差，差值大于 1 则认为是不完全子树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = deepPlus(root, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(result[<span class="number">0</span>] - result[<span class="number">1</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是自上而下的遍历，则必须返回才能判断结果</span></span><br><span class="line">    <span class="comment">// 很明显做了很多无关的判断，使用循环可以通过判断解决该问题，但是算了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] deepPlus(TreeNode node, <span class="keyword">int</span> deep, <span class="keyword">int</span> minDeep, <span class="keyword">boolean</span> isMinGet) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;deep, minDeep&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deepPlus(node.right, deep+<span class="number">1</span>, minDeep, <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deepPlus(node.left, deep+<span class="number">1</span>, minDeep, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minDepth = minDeep;</span><br><span class="line">        <span class="keyword">if</span>(!isMinGet) &#123;</span><br><span class="line">            minDepth += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] leftDeep = deepPlus(node.left, deep + <span class="number">1</span>, minDepth, isMinGet);</span><br><span class="line">        <span class="keyword">int</span>[] rightDeep = deepPlus(node.right, deep + <span class="number">1</span>, minDepth, isMinGet);</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Math.max(leftDeep[<span class="number">0</span>], rightDeep[<span class="number">0</span>]), Math.min(leftDeep[<span class="number">1</span>], rightDeep[<span class="number">1</span>])&#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析：</h4><ul><li>很明显从逻辑上遍历了所有的节点</li><li>(仅限于当前对完全二叉树的认知基础上)可以通过循环遍历更早的对树的性质进行判断</li><li>时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> , 空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="完全二叉树定义"><a class="markdownIt-Anchor" href="#完全二叉树定义"></a> 完全二叉树定义：</h2><h4 id="百度百科"><a class="markdownIt-Anchor" href="#百度百科"></a> 百度百科：</h4><p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><h2 id="平衡二叉树定义"><a class="markdownIt-Anchor" href="#平衡二叉树定义"></a> 平衡二叉树定义：</h2><h4 id="百度百科-2"><a class="markdownIt-Anchor" href="#百度百科-2"></a> 百度百科：</h4><p>平衡树(Balance Tree，BT) 指的是，<font color=purple><strong>任意节点的子树的高度差都小于等于1</strong></font>。常见的符合平衡树的有，B树（多路平衡搜索树）、AVL树（二叉平衡搜索树）等。平衡树可以完成集合的一系列操作, 时间复杂度和空间复杂度相对于“2-3树”要低，在完成集合的一系列操作中始终保持平衡，为大型数据库的组织、索引提供了一条新的途径。</p><div class="note info flat"><p>原来是我搞混了 <strong>平衡二叉树</strong> 与 <strong>完全二叉树</strong> 😂😂</p></div><h3 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二：</h3><p><a href="https://www.modb.pro/db/11333" target="_blank" rel="noopener">https://www.modb.pro/db/11333</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 树结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day 4】 数学方法解题——整数拆分</title>
      <link href="./2020/07/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%204/"/>
      <url>./2020/07/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%204/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="343-整数拆分"><a class="markdownIt-Anchor" href="#343-整数拆分"></a> <a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 你可以假设 _n _不小于 2 且不大于 58。</p><h2 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h2><p>本题其实并不难，但是因为勾起了我对数学的回忆，还是认真解决下，所谓不忘初心嘛</p><p>挺后悔高中的笔记没有留着😂</p><p>记得高中时看到一本书上说“高中可能是脑力的巅峰了” 我还不信，现在信了呵呵。</p><h2 id="方法一数学分析"><a class="markdownIt-Anchor" href="#方法一数学分析"></a> 方法一：数学分析</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><h4 id="麻烦的思路"><a class="markdownIt-Anchor" href="#麻烦的思路"></a> 麻烦的思路：</h4><ul><li>根据我们对均值不等式的印象，很容易判断出将数字等分时能取到最大值，本题的关键变成了将数字分为几份时，取到该最大值。</li><li>考虑n阶不等式，根据不等式性质我们知道当 将 sum 等分时取到最大值，sum为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><mi>a</mi><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum(a1,an)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>能最终得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">a/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">n</span></span></span></span> 等于 e 时取最大值，但是整个过程很乱，证明不等式太复杂</li></ul><h4 id="清晰的思路"><a class="markdownIt-Anchor" href="#清晰的思路"></a> 清晰的思路</h4><ul><li>换一种思路，既然我们一开始就知道将 sum 等分时能取到最大值，那不妨设当sum分为 x 时，乘积最大。(事实上我还是偏向于设分为x份)，解题过程如下：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="C:%5CUsers%5C63026%5CDesktop%5C%E6%8E%A8%E5%AF%BC%E5%87%BD%E6%95%B0%E6%9C%80%E5%A4%A7%E5%80%BC.jpg" alt="推导函数最大值" /></p><h3 id="对应代码如下"><a class="markdownIt-Anchor" href="#对应代码如下"></a> 对应代码如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据结论越逼近f(3)结果越大，所以余1视为4，余2保留</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> number = n / <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">2</span> ? (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, number + <span class="number">1</span>) * left : (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, number) * (<span class="number">3</span> + left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>对于本题，题解中给出的算法复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 也就是说计算次方的算法开销为常数。</li><li>对于 Java Math.pow() 具体实现方式不再进行分析 (毕竟属于无关紧要的部分)</li><li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="方法二动态规划"><a class="markdownIt-Anchor" href="#方法二动态规划"></a> 方法二：动态规划</h2><h3 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h3><p>类似 【每日一题Day 1】分割数组最大值(本题因为数据特征明显所以存在更好的解法);</p><ul><li><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 是对数字 n 的最佳分割</p></li><li><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，很明显只能分成一份，根据题目要求： 0 * 1 = 0；</p></li><li><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>，其可以表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(1, n)dp[i] * (n - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>   (max(1,n) 表示从1到n，后面方程的最大值)</p></li><li><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>时，存在异常情况，此使分为两份更正确。因此必须考虑 i * (n - i) 的情况</p></li></ul><div class="note warning flat"><p>为什么要考虑 i * (n - i) 的情况？ 我认为是因为本题默认最少分割为两块，对于动态变换公式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mi>i</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[n] = dp[i]*(n - i) i\in(1,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>， 其足以遍历所有分割份数大于2的情况，但是由于默认起始位置为 2 的原因，并不能遍历分割数为2的情况，因此需要额外判断 i * (n -i)</p></div><h3 id="实现代码如下"><a class="markdownIt-Anchor" href="#实现代码如下"></a> 实现代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resultBuffer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            resultBuffer = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k&lt;i;k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> midBuffer = Math.max(k * (i-k), result[k] * (i -k));              </span><br><span class="line">                resultBuffer = Math.max(resultBuffer, midBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = resultBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="额外的优化"><a class="markdownIt-Anchor" href="#额外的优化"></a> 额外的优化</h2><p>该题对应的题解上还对动态转移方程进行了进一步的优化，但实际上其对应的思路有种“知道答案推结果的感觉”，因此不再给出</p><div class="note info flat"><p>事实上，我们肯定能证明 对于 n1 &gt; n2, 一定有 n1 分割的次数 大于等于 n2 分割的次数，但是就本题而言，记录分割次数并没有太多必要。</p></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day 3】逆向思维——逃离大迷宫</title>
      <link href="./2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/"/>
      <url>./2020/07/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%203/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话"><a class="markdownIt-Anchor" href="#写在前面的话"></a> 写在前面的话</h1><p><font color=#FF1493 font = 10><strong>虽然没有做多少题呢，但是我已经发现了，做题，怕的不是没有思路，而是不敢尝试。</strong></font></p><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="1036-逃离大迷宫"><a class="markdownIt-Anchor" href="#1036-逃离大迷宫"></a> <a href="https://leetcode-cn.com/problems/escape-a-large-maze/" target="_blank" rel="noopener">1036. 逃离大迷宫</a></h3><p>Difficulty: <strong>困难</strong></p><p>在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 <code>(x, y)</code>，其中 <code>0 &lt;= x, y &lt; 10^6</code>。</p><p>我们从源方格 <code>source</code> 开始出发，意图赶往目标方格 <code>target</code>。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 <code>blocked</code> 上。</p><p>只有在可以通过一系列的移动到达目标方格时才返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [[0,1],[1,0]], source &#x3D; [0,0], target &#x3D; [0,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">从源方格无法到达目标方格，因为我们无法在网格中移动。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：blocked &#x3D; [], source &#x3D; [0,0], target &#x3D; [999999,999999]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">因为没有方格被封锁，所以一定可以到达目标方格。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= blocked.length &lt;= 200</code></li><li><code>blocked[i].length == 2</code></li><li><code>0 &lt;= blocked[i][j] &lt; 10^6</code></li><li><code>source.length == target.length == 2</code></li><li><code>0 &lt;= source[i][j], target[i][j] &lt; 10^6</code></li><li><code>source != target</code></li></ol><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析：</h2><p>本题可以抽象为，能不能通过 blocked 将网格分成互不连通的两部分，且起点与原点分别位于分割线的两侧。进一步观察所给的参数：</p><ul><li>网格大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，基本可以放弃对网格做什么操作了。</li><li>blocked.length 的范围为 [0,200] ，完全在一个可接受的范围内，可以尝试从此入手</li></ul><h2 id="方法一寻找链接原点与终点的路径"><a class="markdownIt-Anchor" href="#方法一寻找链接原点与终点的路径"></a> 方法一：寻找链接原点与终点的路径</h2><p>老实说，该方法我还没看懂，在此贴出对应的链接地址，有兴趣可以试试这种方法😂</p><p><a href="https://leetcode-cn.com/problems/escape-a-large-maze/solution/cong-zhang-ai-wu-dian-blockedru-shou-de-kuai-su-su/" target="_blank" rel="noopener">从障碍物点入手的快速算法</a></p><h2 id="方法二-逆向思维判断是否存在满足题意的路径"><a class="markdownIt-Anchor" href="#方法二-逆向思维判断是否存在满足题意的路径"></a> 方法二： 逆向思维判断是否存在满足题意的路径</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><ul><li><p>提示里提到： 0&lt;= blocked.length &lt;=200; 也就是说圈起来的面积存在最大值。</p></li><li><p>根据抽屉原理，当从该点出发可以达到的面积大于圈起来的面积时，我们可以认为该点一定在圈外。</p></li><li><p>根据以上原理，判断起点终点是否同时在圈内或圈外即可</p></li></ul><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><ul><li>注意两点都在圈内的情况</li><li>对边界进行限制（0可以取到 😂）</li></ul><h3 id="代码实现如下"><a class="markdownIt-Anchor" href="#代码实现如下"></a> 代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] aroundArray = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outNumber = <span class="number">19901</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mapLength = <span class="number">1000000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEscapePossible</span><span class="params">(<span class="keyword">int</span>[][] blocked, <span class="keyword">int</span>[] source, <span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 hashmap 管理 blocked，降低检索造成的开销</span></span><br><span class="line">        <span class="keyword">if</span> (blocked.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;String&gt; blockedTable = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] location : blocked) &#123;</span><br><span class="line">            blockedTable.add(changeArrayToString(location));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 200 个点最多限制的格子数目为： 19900，当超出该数目时，意味着超出Block可圈界限</span></span><br><span class="line">        <span class="comment">// 取 19901 作为判断基准</span></span><br><span class="line">        <span class="keyword">return</span> isInBlocked(blockedTable, source, outNumber, changeArrayToString(target)) &amp;&amp; isInBlocked(blockedTable, target, outNumber, changeArrayToString(source));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInBlocked</span><span class="params">(HashSet&lt;String&gt; blockedTable, <span class="keyword">int</span>[] source, <span class="keyword">int</span> limitsNum, String targetStr)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; aroundQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        aroundQueue.add(source);</span><br><span class="line">        <span class="comment">// 记录走过的方格的 哈希表</span></span><br><span class="line">        HashSet&lt;String&gt; walkedSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        walkedSet.add(changeArrayToString(source));</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!aroundQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] node = aroundQueue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aroundArray.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] bufferNode = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                bufferNode[<span class="number">0</span>] = node[<span class="number">0</span>] + aroundArray[i];</span><br><span class="line">                bufferNode[<span class="number">1</span>] = node[<span class="number">1</span>] + aroundArray[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(isInArray(bufferNode[<span class="number">0</span>])&amp;&amp;isInArray(bufferNode[<span class="number">1</span>])) &#123;</span><br><span class="line">                    String locStr = changeArrayToString(bufferNode);</span><br><span class="line">                    <span class="keyword">if</span>((!blockedTable.contains(locStr)) &amp;&amp; (!walkedSet.contains(locStr)))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(locStr.equals(targetStr))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        aroundQueue.add(bufferNode);</span><br><span class="line">                        num++;</span><br><span class="line">                        walkedSet.add(locStr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= limitsNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">changeArrayToString</span><span class="params">(<span class="keyword">int</span>[] location)</span> </span>&#123;</span><br><span class="line">        StringBuilder strBuild = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        strBuild.append(location[<span class="number">0</span>]);</span><br><span class="line">        strBuild.append(<span class="string">","</span>);</span><br><span class="line">        strBuild.append(location[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> strBuild.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(location &gt;= <span class="number">0</span> &amp;&amp; location &lt; mapLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>算法复杂度：</p><ul><li>如我们所见，该算法实际作用域特定情况，我们甚至可以求出他的最大运算次数，所以大概跟复杂度不沾边了😂</li><li>额外声明了两个哈希表，用于存储不能行走的方格</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>编程题不一定用到编程技巧，或者说其实算法更侧重数学</li><li>对于 “是否存在” 问题，多考虑能否通过条件证明其存在，而不是求出该路径</li></ul><h2 id="下面这篇文章侧重于编程技巧"><a class="markdownIt-Anchor" href="#下面这篇文章侧重于编程技巧"></a> 下面这篇文章侧重于编程技巧：</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 抽屉原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day 2】 矩阵中的最长递增路径</title>
      <link href="./2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/"/>
      <url>./2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%202/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="329-矩阵中的最长递增路径"><a class="markdownIt-Anchor" href="#329-矩阵中的最长递增路径"></a> <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><h2 id="方法一-记忆化深度优先搜索"><a class="markdownIt-Anchor" href="#方法一-记忆化深度优先搜索"></a> 方法一： 记忆化深度优先搜索</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析：</h3><p>对于本题很容易找到解题思路：</p><ul><li>找到每个位置可以到达的下个位置（构造了树结构）</li><li>找到构造的树结构所能到达的最大深度</li></ul><p>我们的树结构看起来不那么好构造，但实际上我们需要获得的是树的深度，因此：</p><ul><li>创建额外的空间存储以当前数字为根节点构造的树所能达到的最大深度</li><li>列出动态转移方程： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo>∑</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>a</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(\sum(0, around))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>around 指矩阵的四周</li></ul><p>根据思路编写实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组模拟遍历操作(也可以模拟九宫格，应该可以😂)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] besideList = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 与其在函数外部对 0、null判断，不如交给函数内部判断。 切记切记</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> sizeX = matrix.length;</span><br><span class="line">       <span class="keyword">int</span> sizeY = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] resultDeep = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;sizeX;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sizeY;j++)&#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,i,j,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxDeep;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] resultDeep)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(resultDeep[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;besideList.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> nowX = x + besideList[i];</span><br><span class="line">           <span class="keyword">int</span> nowY = y + besideList[i+<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(!isInArray(nowX,nowY,matrix))&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(matrix[x][y]&lt;matrix[nowX][nowY]) &#123;</span><br><span class="line">               <span class="keyword">int</span> result = dfs(matrix,nowX,nowY,resultDeep);</span><br><span class="line">               maxDeep = maxDeep&gt;result?maxDeep:result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       resultDeep[x][y] = maxDeep + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> resultDeep[x][y];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 如果返回 boolean ，最好return &#123;逻辑语句&#125; , 而不是通过 if else 返回 true 或 false</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInArray</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;matrix.length&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><ul><li>时间复杂度分析： O(mn),其中 m 和 n 分别是矩阵的行数和列数。深度优先搜索的时间复杂度是 O(V+E)，其中 V 是节点数，E 是边数。在矩阵中，O(V)=O(mn)。</li><li>空间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。空间复杂度主要取决于缓存和递归调用深度，缓存的空间复杂度是 O(mn)，递归调用深度不会超过 mn。</li></ul><h3 id="遗留问题"><a class="markdownIt-Anchor" href="#遗留问题"></a> 遗留问题</h3><p><font color=#FF4500><strong> 对深度优先算法、广度优先算法没有做到掌握，将在之后的篇章给出进一步总结。</strong></font></p><h2 id="方法二拓扑排序动态规划"><a class="markdownIt-Anchor" href="#方法二拓扑排序动态规划"></a> 方法二：拓扑排序（动态规划）</h2><h2 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析：</h2><p>类比寻找二叉树深度的算法，其本质上是 DFS 的循环实现，本题的难点在于如何找到循环的依据：</p><ul><li><p>将数组看作有向图，寻找出度为0的点（即最大点）</p></li><li><p>从所有出度为0的点进行广度优先搜索，并更新出度值，将新的出度为0的点加入搜索队列内</p></li><li><p>搜索总层数即为矩阵中最长递增路径的长度</p><p><font color=#C71585><strong>懒了没有编写对应的实现代码，直接贴了题解</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 太长了不想贴，回头自己写个再补上吧</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析：</h3><p>与方法一相同，但是实现上复杂了许多</p><h3 id="遗留问题-2"><a class="markdownIt-Anchor" href="#遗留问题-2"></a> 遗留问题：</h3><ul><li><p>「方法一」中使用了记忆化存储和深度优先搜索，这里的深度优先搜索可以替换成广度优先搜索吗？</p></li><li><p>「方法二」中基于拓扑排序对排序后的有向无环图做了层次遍历，如果没有拓扑排序直接进行广度优先搜索会发生什么？</p></li><li><p>「方法二」中如果不使用拓扑排序，而是直接按照矩阵中元素的值从大到小进行排序，并依此顺序进行状态转移，那么可以得到正确的答案吗？如果是从小到大进行排序呢？</p></li><li><p>「变式」给定一个整数矩阵，找出符合以下条件的路径的数量：该路径严格递增，切长度至少为3.矩阵边长最大为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，答案对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 取模。其他条件与题目相同。思考对应解法</p></li></ul><h4 id="答案见如下文章"><a class="markdownIt-Anchor" href="#答案见如下文章"></a> 答案见如下文章：</h4><h4 id="文章部分思路借鉴"><a class="markdownIt-Anchor" href="#文章部分思路借鉴"></a> 文章部分思路借鉴：</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/" target="_blank" rel="noopener">leetcode 官方解答</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日一题Day 1】 分割数组的最大值</title>
      <link href="./2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/"/>
      <url>./2020/07/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98Day%201/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><h3 id="410-分割数组的最大值"><a class="markdownIt-Anchor" href="#410-分割数组的最大值"></a> <a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 _m _个非空的连续子数组。设计一个算法使得这 _m _个子数组各自和的最大值最小。</p><p><strong>注意:</strong><br />数组长度 _n _满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><h1 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答"></a> 题目解答</h1><h2 id="方法一-动态规划"><a class="markdownIt-Anchor" href="#方法一-动态规划"></a> 方法一： 动态规划</h2><h3 id="分析过程"><a class="markdownIt-Anchor" href="#分析过程"></a> 分析过程</h3><h4 id="错误的状态转移方程"><a class="markdownIt-Anchor" href="#错误的状态转移方程"></a> 错误的状态转移方程</h4><p>实不相瞒，我第一眼看到该题时，思考的方法为：</p><p>创建 m 个空数组，每次将新数字添加到当前数字之和最小的空数组中。很明显这种方法是不正确的。（脑瘫行为😂）</p><h4 id="正确的状态转移方程"><a class="markdownIt-Anchor" href="#正确的状态转移方程"></a> 正确的状态转移方程</h4><p>题目中提到两个变量，连续子数组个数 m，数组内数字个数n。 我们假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示将前 i 个数字按照要求分为 j 份所能得到的最大连续和的最小值，考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，枚举 k 属于 1~j，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 可以视为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[k][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>k</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_k^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span> 中较大者，详细描述如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC.jpg" alt="分割数组最大值" /></p><p>根据动态转移方程编写对应代码：</p><p>值得注意的是，除了考虑 i &lt; j 的情况，还要注意i 、j 为 0 的初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">// 需要预留(0,0) 的空间，否则会因为初始的 MAX_VALUE 导致结果出错</span></span><br><span class="line">        <span class="keyword">int</span>[][] results = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=length;i++) &#123;</span><br><span class="line">            Arrays.fill(results[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免结果被MAX_VALUE</span></span><br><span class="line">        results[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化前n项和,用于快速计算连续序列的和</span></span><br><span class="line">        <span class="keyword">int</span>[] preArrayResult = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            preArrayResult[i+<span class="number">1</span>] = preArrayResult[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过三层循环 得到f[i][j] 的所有结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i, m); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    <span class="comment">// 根据递推公式转换而来</span></span><br><span class="line">                    results[i][j] = Math.min(results[i][j], Math.max(results[k][j - <span class="number">1</span>], preArrayResult[i] - preArrayResult[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面的循环同理</span></span><br><span class="line">        <span class="comment">// for(int j = 1;j&lt;=m;j++) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int i=0;i&lt;=length; i++)&#123;</span></span><br><span class="line">        <span class="comment">//         for (int k = 0; k &lt; i; k++) &#123;</span></span><br><span class="line">        <span class="comment">//             results[i][j] = Math.min(results[i][j], Math.max(results[k][j - 1], preArrayResult[i] - preArrayResult[k]));</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> results[length][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="方法二-二分查找-贪心"><a class="markdownIt-Anchor" href="#方法二-二分查找-贪心"></a> 方法二： 二分查找 + 贪心</h2><p>原理很简单，很明显我们的答案在一个可以预测的范围内：其下界大于所有数字中最大的数。其上界小于所有数字的和。即：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\in(max(a),\sum(a))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>对于排序的数组内寻找符合条件的值，自然使用二分法，配合贪心算法判断是否存在分割方法满足要求即可。</p><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h3><p><font color=#C71585><strong>这其实是我个人的问题，因为不常写二分查找算法的缘故，这题我加了很多判断条件才算解决</strong></font></p><ul><li>本题可以取下界却不能取上界（下界可能为问题的解）</li><li>修改边界时，对于可取边界要 +1 ： left = mid + 1;</li><li>为了避免整数溢出，最好使用 (right - left) / 2 + left 计算 mid  （我将 mid 设为了 double 类型）</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>不难判断本题的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(sum - maxn))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>类似穷举法的题目还有很多，比如一定范围内质数、符合某项规定的数字等等。可以考虑该解法减少运算量。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/gaoxiang15125/pictureBed/raw/master/img/1595702409237.jpeg" alt="img" /></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
